<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>qpAdm Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,400&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh; background: #111; font-family: 'Roboto', sans-serif;
      color: #e8e8e8; display: flex; flex-direction: column;
      align-items: center; padding: 28px 20px 48px; gap: 20px;
    }
    .app-header { width: 100%; max-width: 1000px; display: flex; align-items: baseline; gap: 12px; }
    .app-title  { font-size: 1.7rem; font-weight: 700; color: #fff; letter-spacing: -0.01em; }
    .app-subtitle { font-size: 0.7rem; font-weight: 500; color: #444; letter-spacing: 0.14em; text-transform: uppercase; }
    .input-panel { width: 100%; max-width: 1000px; display: flex; flex-direction: column; gap: 10px; }
    textarea { width: 100%; height: 150px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #c8c8c8; font-family: monospace; font-size: 11px; line-height: 1.65; padding: 12px 14px; resize: vertical; outline: none; }
    textarea:focus { border-color: #444; }
    textarea::placeholder { color: #333; }
    .controls-row, .social-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .social-field { display: flex; align-items: center; gap: 6px; }
    .social-field label { font-size: 10px; font-weight: 700; color: #444; text-transform: uppercase; letter-spacing: 0.1em; white-space: nowrap; }
    .social-field input { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 6px 9px; width: 120px; outline: none; }
    .social-field input:focus { border-color: #444; }
    .btn { padding: 8px 18px; border: none; border-radius: 3px; font-size: 13px; font-weight: 600; cursor: pointer; }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-dl { background: #2563eb; color: #fff; display: none; }
    .btn-dl:hover { background: #1d4ed8; }
    select { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 8px 10px; cursor: pointer; outline: none; }
    #formatBadge { display: none; font-size: 10px; font-weight: 700; padding: 4px 10px; border-radius: 2px; background: #0d2b18; color: #4ade80; letter-spacing: 0.07em; text-transform: uppercase; }
    #formatBadge.raw { background: #2b1800; color: #fb923c; }

    /* ═══ CARD ═══ */
    #card {
      width: 100%; max-width: 1000px; aspect-ratio: 16 / 10.5;
      background: #fff; border-radius: 4px; display: none;
      position: relative; overflow: visible;
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
    }
    .card-bg { position: absolute; inset: 0; background: #fff; border-radius: 4px; z-index: 0; pointer-events: none; }

    /* ═══ HEADER ═══ */
    .card-header { position: absolute; top: 0; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; z-index: 2; }
    #cardTarget { width: 100%; }
    .stat-sep { color: #bbb; margin: 0 8px; }

    /* ═══ PASS/FAIL — fully positioned via JS VERDICT_POS ═══ */
    .verdict-badge {
      position: absolute;
      border: none; border-radius: 0;
      text-transform: uppercase;
      z-index: 3;
      /* all geometry set by applyVerdictPos() */
    }
    .verdict-badge.pass { background: #dcfce7; color: #19763e; }
    .verdict-badge.fail { background: #fee2e2; color: #b02828; }

    /* ═══ DONUT ═══ */
    #donutWrap { position: absolute; z-index: 10; }
    #donutWrap canvas { width: 100% !important; height: 100% !important; display: block; }

    /* ═══ INFO PANEL ═══ */
    .info-col { position: absolute; display: flex; flex-direction: column; justify-content: center; gap: 10px; min-width: 0; z-index: 2; }

    /* ═══ TABLES ═══ */
    .data-box { border: 1.5px solid #d1d5db; border-radius: 2px; overflow: hidden; }
    .data-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    .data-table thead th { background: #f3f4f6; border-bottom: 1.5px solid #d1d5db; padding: 6px 10px; white-space: nowrap; }
    .data-table tbody td { padding: 5px 10px; border-bottom: 1px solid #e5e7eb; }
    .data-table tbody tr:last-child td { border-bottom: none; }

    /* Sources columns */
    .col-sw   { vertical-align: middle; text-align: left; }
    .col-name { vertical-align: middle; overflow: visible; white-space: normal; word-break: normal; overflow-wrap: normal; }
    .col-data { vertical-align: middle; }

    .swatch  { display: inline-block; vertical-align: middle; flex-shrink: 0; }
    .pop-name { vertical-align: middle; hyphens: none; line-height: 1.35; }

    /* Z-score tiers */
    .z-good { color: #16a34a; }
    .z-mid  { color: #ca8a04; }
    .z-bad  { color: #dc2626; }

    /* Outgroups */
    .outgroups-table thead th { text-align: center !important; }
    .outgroups-td { white-space: normal; word-break: break-word; overflow-wrap: break-word; }

    /* Watermark */
    .watermark { position: absolute; bottom: 8px; right: 12px; z-index: 5; }
  </style>
</head>
<body>

<div class="app-header">
  <h1 class="app-title">qpAdm Visualizer</h1>
  <span class="app-subtitle">Admixture Chart Generator</span>
</div>

<div class="input-panel">
  <textarea id="qpadmText" placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG: full qpAdm output (left pops / right pops / best coefficients / std. errors / f4rank)
SUMMARY:  Target: X | Weights: PopA - 43.8% SE: 3.78% Z: 11.57 | P value: 0.15 | chisq: 8.04 | Rights: …"></textarea>
  <div class="controls-row">
    <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
    <select id="paletteSelect">
      <option value="0">Palette — Default</option>
      <option value="1">Palette — Set1</option>
      <option value="2">Palette — Dark2</option>
      <option value="3">Palette — Pastel</option>
      <option value="4">Palette — Tableau</option>
      <option value="5">Palette — Paired</option>
      <option value="6">Palette — Soft</option>
      <option value="7">Palette — Vibrant</option>
      <option value="8">Palette — Classic</option>
      <option value="9">Palette — Mixed</option>
    </select>
    <span id="formatBadge"></span>
    <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ Download PNG</button>
  </div>
  <div class="social-row">
    <div class="social-field"><label>Telegram</label><input type="text" id="telegramInput" placeholder="@username"></div>
    <div class="social-field"><label>X / Twitter</label><input type="text" id="xInput" placeholder="@username"></div>
    <div class="social-field"><label>Discord</label><input type="text" id="discordInput" placeholder="username"></div>
  </div>
</div>

<!-- CARD -->
<div id="card">
  <div class="card-bg"></div>
  <div class="card-header" id="cardHeader">
    <div id="cardTarget"></div>
    <div id="statLine"></div>
    <div class="verdict-badge" id="verdictBadge"></div>
  </div>
  <div id="donutWrap"><canvas id="donutChart"></canvas></div>
  <div class="info-col" id="infoCol">
    <div class="data-box" id="sourcesBox">
      <table class="data-table" id="sourcesTable">
        <thead id="sourcesHead"></thead>
        <tbody id="sourcesBody"></tbody>
      </table>
    </div>
    <div class="data-box" id="outgroupsBox" style="display:none;">
      <table class="data-table outgroups-table">
        <thead><tr><th id="hdrOutgroups"></th></tr></thead>
        <tbody><tr><td class="outgroups-td" id="outgroupsTd"></td></tr></tbody>
      </table>
    </div>
  </div>
  <div class="watermark" id="watermark"></div>
</div>

<script>
/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  LAYOUT  —  positions as % of card width (X) or card height (Y)         ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const LAYOUT = {
  donutCenterX:   25,   /* % card W — donut centre horizontal */
  donutCenterY:   55,   /* % card H — donut centre vertical   */
  donutDiameter:  46,   /* % card W — donut diameter          */

  panelLeft:       48,  /* % card W — info panel left edge    */
  panelTop:        18,  /* % card H — info panel top edge     */
  panelRight:       2,  /* % card W — info panel right inset  */
  panelBottom:      3,  /* % card H — info panel bottom inset */
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  VERDICT BADGE POSITION & SIZE                                           ║
   ║                                                                          ║
   ║  anchorX / anchorY  — position of badge anchor as % of card W / H       ║
   ║  anchor             — which corner of the badge sits at anchorX/Y:       ║
   ║                       'top-right' | 'top-left' | 'top-center'           ║
   ║                       'bottom-right' | 'bottom-left' | 'bottom-center'  ║
   ║  minWidth           — minimum badge width in px (0 = auto)              ║
   ║  minHeight          — minimum badge height in px (0 = auto)             ║
   ║  paddingV / paddingH — inner padding in px                               ║
   ║  textAlign          — text alignment within badge: 'left'|'center'|'right'║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const VERDICT_POS = {
  anchorX:    98,           /* % card W — badge anchor X       */
  anchorY:    3,            /* % card H — badge anchor Y       */
  anchor:     'top-right',  /* which corner of badge is at X/Y */
  minWidth:   0,            /* px, 0 = auto                    */
  minHeight:  0,            /* px, 0 = auto                    */
  paddingV:   8,            /* px inner vertical padding       */
  paddingH:   8,            /* px inner horizontal padding     */
  textAlign:  'center',     /* text alignment within badge     */
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  DONUT CONFIG                                                            ║
   ╠══════════════════════════════════════════════════════════════════════════╣
   ║  donutCutout      '0%' = solid pie  '90%' = thin ring                   ║
   ║  donutBorderW     slice border width px                                  ║
   ║  donutBorderC     slice border colour                                    ║
   ║  donutHoverOff    px expansion on hover                                  ║
   ║  donutClockwise   true = CW  │  false = anti-clockwise                  ║
   ║  donutStartAngle  degrees: 90=6-o'clock -90=12 0=3 180=9               ║
   ║  zGoodMin         Z ≥ this → green                                      ║
   ║  zMidMin          Z ≥ this → amber  (below → red)                      ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const CFG = {
  donutCutout:      '65%',
  donutBorderW:     2,
  donutBorderC:     '#000000',
  donutHoverOff:    14,
  donutClockwise:   true,
  donutStartAngle:  0,
  zGoodMin:         3,
  zMidMin:          2,
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  SWATCH                                                                  ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const SWATCH = {
  width:   '25px',
  height:  '19px',
  radius:  '0px',
  border:  '1.8px solid #000',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  TYPOGRAPHY  —  every text element on the output card                    ║
   ║                                                                          ║
   ║  Keys available in every section:                                        ║
   ║    font           CSS font-family string                                 ║
   ║    fontSize       CSS font-size  (px / em / vw / clamp(…))              ║
   ║    fontWeight     100–900                                                ║
   ║    fontStyle      'normal' | 'italic' | 'oblique'                       ║
   ║    color          any CSS colour                                         ║
   ║    letterSpacing  e.g. '-0.02em'                                         ║
   ║    lineHeight     e.g. '1.4'                                             ║
   ║    align          'left' | 'center' | 'right'                           ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const TYPOGRAPHY = {

  /* ── Large population name heading ── */
  target: {
    font:          'Roboto, sans-serif',
    fontSize:      'clamp(40px, 4.5vw, 60px)',
    fontWeight:    900,
    fontStyle:     'normal',
    color:         '#0a0a0a',
    letterSpacing: '-0.02em',
    lineHeight:    '1.05',
    align:         'center',
  },

  /* ── χ² / p-value stat line ── */
  stat: {
    font:          'Cascadia Code, sans-serif',
    fontSize:      'clamp(18px, 2.0vw, 30px)',
    fontWeight:    400,
    fontStyle:     'normal',
    color:         '#555555',
    letterSpacing: '0.01em',
    lineHeight:    '1.3',
    align:         'center',
    marginTop:     '2px',
  },

  /* ── Card header padding (controls gap above content) ── */
  headerPadding: {
    top:    '10px',
    sides:  '24px',
    bottom: '0px',
  },

  /* ── PASS / FAIL text style (position controlled by VERDICT_POS above) ── */
  verdict: {
    font:          'Roboto, sans-serif',
    fontSize:      'clamp(15px, 2.0vw, 23px)',
    fontWeight:    600,
    fontStyle:     'normal',
    letterSpacing: '0.12em',
    /* background & text colour live in .pass / .fail CSS classes */
  },

  /* ── Sources table: single merged header ── */
  sourcesHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Coeff \u00B1 SE  (Z-score)',
    textTransform: 'uppercase',
  },

  /* ── Source name cell ── */
  sourcesName: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    lineHeight:    '1.35',
    align:         'left',
  },

  /* ── Coeff ± SE portion of data cell ── */
  sourcesCoeff: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    align:         'left',
  },

  /* ── Z-score portion of data cell ──
     zPrefix      text before the number inside the bracket
     zSep         space between coeff block and the opening paren
     zGap         CSS gap between "Z:" label and the number        */
  sourcesZ: {
    font:          'Roboto, sans-serif',
    fontSize:      '13px',
    fontWeight:    700,
    fontStyle:     'normal',
    letterSpacing: '0',
    zPrefix:       'Z:\u2009',   /* thin-space after colon */
    zSep:          '  ',         /* gap before opening paren */
    zGap:          '3px',
  },

  /* ── Colon separator between name and data ──
     colonText    the actual text used as separator (default ': ')
     colonFont    font for the colon — usually matches coeff font
     colonColor   colour of the colon character                    */
  sourcesColon: {
    colonText:   ': ',
    colonFont:   'Roboto, sans-serif',
    colonColor:  '#111111',
  },

  /* ── Per-row overrides ──────────────────────────────────────────────────
     { index: N, <prefixed key>: value }
     name*   → nameFont  nameFontSize  nameFontWeight  nameFontStyle
               nameColor  nameLetterSpacing  nameLineHeight  nameAlign
     coeff*  → coeffFont  coeffFontSize  coeffFontWeight  coeffFontStyle
               coeffColor  coeffLetterSpacing  coeffAlign
     z*      → zFont  zFontSize  zFontWeight  zFontStyle  zLetterSpacing  zGap
     Examples:
       { index: 0, nameColor: '#e63946', nameFontWeight: 700 }
       { index: 1, coeffColor: '#2563eb' }                                  */
  sourcesRowOverrides: [
    // { index: 0, nameColor: '#e63946' },
  ],

  /* ── Outgroups header ── */
  outgroupsHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Right (Outgroups)',
    textTransform: 'uppercase',
  },

  /* ── Outgroups data cell ── */
  outgroupsCell: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0',
    lineHeight:    '1.6',
    align:         'left',
  },

  /* ── Watermark ── */
  watermark: {
    font:          'Roboto, sans-serif',
    fontSize:      '9px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#c0cad6',
    letterSpacing: '0.05em',
  },
};

/* ══════════════════════════════════════════════════════════════════
   COLOR PALETTES
══════════════════════════════════════════════════════════════════ */
const colorPalettes = [
  ["#4477aa","#ee6677","#228833","#ccbb44","#66ccee","#aa3377","#bbbbbb","#44bb99","#eedd88","#77aadd"],
  ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#a65628","#f781bf","#999999","#66c2a5","#fc8d62"],
  ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666","#1f78b4","#b2df8a"],
  ["#8dd3c7","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5"],
  ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],
  ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a"],
  ["#a8dadc","#457b9d","#e63946","#f4a261","#2a9d8f","#e9c46a","#264653","#b5838d","#6d6875","#c77dff"],
  ["#ff595e","#ffca3a","#6a4c93","#1982c4","#8ac926","#f86624","#ea3546","#662e9b","#43bccd","#f9c80e"],
  ["#264653","#2a9d8f","#e9c46a","#f4a261","#e76f51","#a8dadc","#457b9d","#1d3557","#e63946","#52b788"],
  ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3","#a6761d","#1b9e77"],
];

let chartObj = null;

/* ── Apply TYPOGRAPHY section to a DOM element ── */
function applyT(el, t) {
  if (!el || !t) return;
  if (t.font)          el.style.fontFamily    = t.font;
  if (t.fontSize)      el.style.fontSize      = t.fontSize;
  if (t.fontWeight)    el.style.fontWeight    = t.fontWeight;
  if (t.fontStyle)     el.style.fontStyle     = t.fontStyle;
  if (t.color)         el.style.color         = t.color;
  if (t.letterSpacing) el.style.letterSpacing = t.letterSpacing;
  if (t.lineHeight)    el.style.lineHeight    = t.lineHeight;
  if (t.align)         el.style.textAlign     = t.align;
}

/* ── Apply LAYOUT to donut + info panel ── */
function applyLayout() {
  const card = document.getElementById('card');
  const wrap = document.getElementById('donutWrap');
  const info = document.getElementById('infoCol');
  const cW = card.offsetWidth, cH = card.offsetHeight;
  const d  = (LAYOUT.donutDiameter / 100) * cW;
  const cx = (LAYOUT.donutCenterX  / 100) * cW;
  const cy = (LAYOUT.donutCenterY  / 100) * cH;
  wrap.style.width  = d + 'px';
  wrap.style.height = d + 'px';
  wrap.style.left   = (cx - d / 2) + 'px';
  wrap.style.top    = (cy - d / 2) + 'px';
  info.style.left   = ((LAYOUT.panelLeft   / 100) * cW) + 'px';
  info.style.top    = ((LAYOUT.panelTop    / 100) * cH) + 'px';
  info.style.right  = ((LAYOUT.panelRight  / 100) * cW) + 'px';
  info.style.bottom = ((LAYOUT.panelBottom / 100) * cH) + 'px';
}

/* ── Apply VERDICT_POS to badge ──
   Positions the badge by computing its px coordinates from % values,
   then offsetting based on which corner of the badge is at anchorX/Y.
   We use a two-pass: render offscreen to measure, then position.         */
function applyVerdictPos(vb) {
  const card = document.getElementById('card');
  const cW   = card.offsetWidth, cH = card.offsetHeight;
  const vp   = VERDICT_POS;
  const vt   = TYPOGRAPHY.verdict;

  /* Base style */
  applyT(vb, vt);
  vb.style.padding    = `${vp.paddingV}px ${vp.paddingH}px`;
  vb.style.textAlign  = vp.textAlign;
  if (vp.minWidth  > 0) vb.style.minWidth  = vp.minWidth  + 'px';
  if (vp.minHeight > 0) vb.style.minHeight = vp.minHeight + 'px';

  /* Temporarily position off-screen to measure size */
  vb.style.visibility = 'hidden';
  vb.style.left = '0'; vb.style.top = '0';
  vb.style.right = ''; vb.style.bottom = '';

  /* Read rendered dimensions */
  const bW = vb.offsetWidth, bH = vb.offsetHeight;
  vb.style.visibility = '';

  /* Anchor point in px */
  const ax = (vp.anchorX / 100) * cW;
  const ay = (vp.anchorY / 100) * cH;

  /* Compute left/top from anchor corner */
  let left, top;
  const a = vp.anchor || 'top-right';
  const hPart = a.includes('left')   ? 0
              : a.includes('right')  ? 1
              : a.includes('center') ? 0.5 : 1;
  const vPart = a.includes('bottom') ? 1
              : a.includes('center') && !a.includes('top') && !a.includes('bottom') ? 0.5
              : 0;
  left = ax - hPart * bW;
  top  = ay - vPart * bH;

  vb.style.left   = left + 'px';
  vb.style.top    = top  + 'px';
  vb.style.right  = '';
  vb.style.bottom = '';
}

/* ── Soft-break long names at _ . - ── */
function softBreak(s) { return s.replace(/([_.\-])/g, '$1<wbr>'); }

/* ── Merge per-row override with typography defaults ── */
function mergeRow(i) {
  const base = {
    nameFont:           TYPOGRAPHY.sourcesName.font,
    nameFontSize:       TYPOGRAPHY.sourcesName.fontSize,
    nameFontWeight:     TYPOGRAPHY.sourcesName.fontWeight,
    nameFontStyle:      TYPOGRAPHY.sourcesName.fontStyle      || 'normal',
    nameColor:          TYPOGRAPHY.sourcesName.color,
    nameLetterSpacing:  TYPOGRAPHY.sourcesName.letterSpacing  || '0',
    nameLineHeight:     TYPOGRAPHY.sourcesName.lineHeight      || '1.35',
    nameAlign:          TYPOGRAPHY.sourcesName.align,
    coeffFont:          TYPOGRAPHY.sourcesCoeff.font,
    coeffFontSize:      TYPOGRAPHY.sourcesCoeff.fontSize,
    coeffFontWeight:    TYPOGRAPHY.sourcesCoeff.fontWeight,
    coeffFontStyle:     TYPOGRAPHY.sourcesCoeff.fontStyle     || 'normal',
    coeffColor:         TYPOGRAPHY.sourcesCoeff.color,
    coeffLetterSpacing: TYPOGRAPHY.sourcesCoeff.letterSpacing || '0',
    coeffAlign:         TYPOGRAPHY.sourcesCoeff.align,
    zFont:              TYPOGRAPHY.sourcesZ.font,
    zFontSize:          TYPOGRAPHY.sourcesZ.fontSize,
    zFontWeight:        TYPOGRAPHY.sourcesZ.fontWeight,
    zFontStyle:         TYPOGRAPHY.sourcesZ.fontStyle         || 'normal',
    zLetterSpacing:     TYPOGRAPHY.sourcesZ.letterSpacing     || '0',
    zGap:               TYPOGRAPHY.sourcesZ.zGap,
  };
  const ov = TYPOGRAPHY.sourcesRowOverrides.find(r => r.index === i);
  return ov ? Object.assign({}, base, ov) : base;
}

function isRawFormat(t) { return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t); }

/* ── Raw qpAdm log parser ── */
function parseRaw(text) {
  const lines = text.split('\n');
  const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
  if (li < 0) throw new Error('"left pops:" not found');
  const lp = [];
  for (let i = li+1; i < lines.length; i++) {
    const l = lines[i].trim();
    if (!l || /^right pops/i.test(l)) break;
    const m = l.match(/^(\S+)\s+\d+/); if (m) lp.push(m[1]);
  }
  if (lp.length < 2) throw new Error('Need target + ≥1 source in left pops');
  const target = lp[0], sources = lp.slice(1);

  const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
  const rp = [];
  if (ri >= 0) {
    for (let i = ri+1; i < lines.length; i++) {
      const l = lines[i].trim();
      if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
      const m = l.match(/^(\S+)\s+\d+/); if (m) rp.push(m[1]);
    }
  }

  let pValue = NaN, chisq = NaN;
  const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
  if (ci >= 0) {
    for (let i = ci+1; i < Math.min(ci+6, lines.length); i++) {
      const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
    }
  }
  if (isNaN(pValue)) {
    for (const l of lines) {
      const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
    }
  }
  if (isNaN(pValue)) throw new Error('Could not parse p-value');

  const cl = lines.find(l => /best coefficients:/.test(l));
  if (!cl) throw new Error('"best coefficients:" not found');
  const coeffs = cl.replace('best coefficients:','').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (coeffs.length !== sources.length) throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);

  const sl = lines.find(l => /std\.\s*errors:/.test(l));
  if (!sl) throw new Error('"std. errors:" not found');
  const ses = sl.replace(/std\.\s*errors:/,'').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (ses.length !== sources.length) throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);

  const tot = coeffs.reduce((a,b)=>a+b,0);
  return {
    target, sources,
    weights: coeffs.map(c=>(c/tot)*100),
    sesPct:  ses.map(s=>s*100),
    zScores: coeffs.map((c,i)=>ses[i]>0?c/ses[i]:0),
    pValue, chisq, outgroups: rp.join(', ')
  };
}

/* ── Summary format parser ── */
function parseSummary(text) {
  const lines = text.split('\n').map(l=>l.trim()).filter(Boolean);
  const tl = lines.find(l=>l.startsWith('Target:'));
  if (!tl) throw new Error('Target line not found');
  const target = tl.replace('Target:','').trim();
  const ws = lines.findIndex(l=>l.startsWith('Weights:'));
  if (ws < 0) throw new Error('Weights section not found');
  const pvl = lines.find(l=>l.startsWith('P value:')), chl = lines.find(l=>l.startsWith('chisq:'));
  if (!pvl) throw new Error('P value not found'); if (!chl) throw new Error('chisq not found');
  const pValue = parseFloat(pvl.replace('P value:','').trim());
  const chisq  = parseFloat(chl.replace('chisq:','').trim());
  const rgl    = lines.find(l=>l.startsWith('Rights:'));
  const outgroups = rgl ? rgl.replace('Rights:','').trim() : '';
  const sources=[],weights=[],sesPct=[],zScores=[];
  for (let i=ws+1; i<lines.length; i++) {
    const l = lines[i];
    if (/^(P value:|chisq:|Rights:)/.test(l)) break;
    const m = l.match(/^(.+?)\s*-\s*([\d.]+)%\s*SE:\s*([\d.]+)%\s*Z:\s*([-\d.]+)/);
    if (m) {
      sources.push(m[1].trim());
      weights.push(parseFloat(m[2]));
      sesPct.push(parseFloat(m[3]));
      zScores.push(parseFloat(m[4]));
    }
  }
  if (!sources.length) throw new Error('No populations found');
  const tot = weights.reduce((a,b)=>a+b,0);
  return { target, sources, weights: weights.map(w=>(w/tot)*100), sesPct, zScores, pValue, chisq, outgroups };
}

function zClass(z) { return z >= CFG.zGoodMin ? 'z-good' : (z >= CFG.zMidMin ? 'z-mid' : 'z-bad'); }

/* ═══ MAIN RENDER ═══ */
function parseAndDraw() {
  const text = document.getElementById('qpadmText').value.trim();
  document.getElementById('card').style.display        = 'none';
  document.getElementById('downloadBtn').style.display = 'none';

  try {
    let parsed, fmtTxt, fmtCls;
    if (isRawFormat(text)) { parsed = parseRaw(text);     fmtTxt = '⚙ Raw log'; fmtCls = 'raw'; }
    else                   { parsed = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = ''; }
    const badge = document.getElementById('formatBadge');
    badge.textContent = fmtTxt; badge.className = fmtCls; badge.style.display = 'inline-block';

    const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;

    /* ── Header padding ── */
    const hp  = TYPOGRAPHY.headerPadding;
    const hdr = document.getElementById('cardHeader');
    hdr.style.padding = `${hp.top} ${hp.sides} ${hp.bottom} ${hp.sides}`;

    /* ── Target ── */
    const tEl = document.getElementById('cardTarget');
    tEl.textContent = 'Target: ' + target;
    applyT(tEl, TYPOGRAPHY.target);

    /* ── Stat line ── */
    const pd   = pValue < 0.0001 ? pValue.toExponential(4) : parseFloat(pValue.toPrecision(7)).toString();
    const slEl = document.getElementById('statLine');
    slEl.innerHTML = `χ² = ${chisq.toFixed(2)}<span class="stat-sep"> / </span>p = ${pd}`;
    applyT(slEl, TYPOGRAPHY.stat);
    slEl.style.marginTop = TYPOGRAPHY.stat.marginTop || '2px';

    /* ── Show card first (needed for measurements) ── */
    document.getElementById('card').style.display = 'block';

    /* ── Verdict badge ── */
    const pass = pValue >= 0.05;
    const vb   = document.getElementById('verdictBadge');
    vb.textContent = pass ? 'PASS' : 'FAIL';
    vb.className   = 'verdict-badge ' + (pass ? 'pass' : 'fail');
    applyVerdictPos(vb);

    /* ── Layout ── */
    applyLayout();

    /* ── Colors ── */
    const pidx   = parseInt(document.getElementById('paletteSelect').value);
    const pal    = colorPalettes[pidx];
    const colors = sources.map((_,i) => i < pal.length ? pal[i] : `hsl(${Math.round(360*i/sources.length)},62%,52%)`);

    /* ── Donut ── */
    const ctx = document.getElementById('donutChart').getContext('2d');
    if (chartObj) chartObj.destroy();
    chartObj = new Chart(ctx, {
      type: 'doughnut',
      data: { labels: sources, datasets: [{
        data: weights,
        backgroundColor: colors, hoverBackgroundColor: colors,
        borderColor: CFG.donutBorderC, hoverBorderColor: CFG.donutBorderC,
        borderWidth: CFG.donutBorderW, hoverBorderWidth: CFG.donutBorderW,
        hoverOffset: CFG.donutHoverOff,
      }]},
      options: {
        responsive: true, cutout: CFG.donutCutout,
        rotation:      CFG.donutStartAngle,
        circumference: CFG.donutClockwise ? 360 : -360,
        layout: { padding: CFG.donutHoverOff },
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` } }
        },
        animation: { animateRotate: true, duration: 550 }
      }
    });

    /* ═══ SOURCES TABLE ═══
       Header row:  [empty swatch th] [colspan=2 merged header]
       Data rows:   [swatch]  [pop name]  [: coeff ± SE  (Z: z.zz)]
    ═══ */
    const sh     = TYPOGRAPHY.sourcesHeader;
    const swColW = (parseInt(SWATCH.width) + 16) + 'px';

    document.getElementById('sourcesHead').innerHTML = `
      <tr>
        <th style="width:${swColW};background:#f3f4f6;border-bottom:1.5px solid #d1d5db;padding:5px 0 5px 10px;"></th>
        <th colspan="2" style="
          font-family:${sh.font};font-size:${sh.fontSize};
          font-weight:${sh.fontWeight};font-style:${sh.fontStyle||'normal'};
          color:${sh.color};letter-spacing:${sh.letterSpacing};
          line-height:${sh.lineHeight};text-align:${sh.align};
          text-transform:${sh.textTransform||'uppercase'};
          background:#f3f4f6;border-bottom:1.5px solid #d1d5db;
          padding:5px 10px;white-space:nowrap;
        ">${sh.text}</th>
      </tr>`;

    /* ── Source rows ── */
    const zT  = TYPOGRAPHY.sourcesZ;
    const sc  = TYPOGRAPHY.sourcesColon;
    let srcHTML = '';

    sources.forEach((pop, i) => {
      const rs  = mergeRow(i);
      const z   = zScores[i];
      const zCl = zClass(z);

      /*  Z block inside parens: (Z: 12.41)  */
      const zBlock = `<span class="${zCl}" style="
            font-family:${rs.zFont};font-size:${rs.zFontSize};
            font-weight:${rs.zFontWeight};font-style:${rs.zFontStyle};
            letter-spacing:${rs.zLetterSpacing};white-space:nowrap;
          ">(${zT.zPrefix}<span style="
            display:inline-grid;grid-template-columns:auto auto;
            gap:${rs.zGap};align-items:center;
          "><span style="white-space:nowrap;"></span
          ><span style="min-width:3.5ch;text-align:right;white-space:nowrap;">${z.toFixed(2)}</span
          ></span>)</span>`;

      /*  Colon separator  */
      const colonHtml = `<span style="
            font-family:${sc.colonFont};
            color:${sc.colonColor};
            white-space:pre;
          ">${sc.colonText}</span>`;

      /*  Full data cell: ": coeff ± se   (Z: 12.41)"  */
      const dataHtml = `${colonHtml}<span style="
            font-family:${rs.coeffFont};font-size:${rs.coeffFontSize};
            font-weight:${rs.coeffFontWeight};font-style:${rs.coeffFontStyle};
            color:${rs.coeffColor};letter-spacing:${rs.coeffLetterSpacing};
            white-space:nowrap;
          ">${weights[i].toFixed(1)}% \u00B1 ${sesPct[i].toFixed(2)}%</span>${zT.zSep}${zBlock}`;

      srcHTML += `<tr>
        <td class="col-sw" style="width:${swColW};padding:5px 0 5px 10px !important;vertical-align:middle;">
          <span class="swatch" style="
            background:${colors[i]};
            width:${SWATCH.width};height:${SWATCH.height};
            border-radius:${SWATCH.radius};border:${SWATCH.border};
          "></span>
        </td>
        <td class="col-name" style="text-align:${rs.nameAlign};padding-left:4px !important;vertical-align:middle;">
          <span class="pop-name" style="
            font-family:${rs.nameFont};font-size:${rs.nameFontSize};
            font-weight:${rs.nameFontWeight};font-style:${rs.nameFontStyle};
            color:${rs.nameColor};letter-spacing:${rs.nameLetterSpacing};
            line-height:${rs.nameLineHeight};
          ">${softBreak(pop)}</span>
        </td>
        <td class="col-data" style="
          text-align:${rs.coeffAlign};white-space:nowrap;vertical-align:middle;
        ">${dataHtml}</td>
      </tr>`;
    });

    document.getElementById('sourcesBody').innerHTML = srcHTML;

    /* ── Outgroups ── */
    const ogBox = document.getElementById('outgroupsBox');
    const ogTd  = document.getElementById('outgroupsTd');
    const ogH   = document.getElementById('hdrOutgroups');
    const ogh   = TYPOGRAPHY.outgroupsHeader;
    const ogc   = TYPOGRAPHY.outgroupsCell;
    if (outgroups) {
      ogH.textContent = ogh.text;
      applyT(ogH, ogh);
      ogH.style.textTransform = ogh.textTransform || 'uppercase';
      ogH.style.padding = '5px 10px';
      applyT(ogTd, ogc);
      ogTd.style.padding = '5px 10px';
      ogTd.textContent    = outgroups;
      ogBox.style.display = 'block';
    } else {
      ogBox.style.display = 'none';
    }

    /* ── Watermark ── */
    const wEl = document.getElementById('watermark');
    applyT(wEl, TYPOGRAPHY.watermark);
    const tg = document.getElementById('telegramInput').value.trim();
    const xw = document.getElementById('xInput').value.trim();
    const dc = document.getElementById('discordInput').value.trim();
    const pts = [];
    if (tg) pts.push('TG: '+tg);
    if (xw) pts.push('X: '+xw);
    if (dc) pts.push('DC: '+dc);
    wEl.textContent = pts.join('  \u00B7  ');

    document.getElementById('downloadBtn').style.display = 'inline-block';

  } catch(e) { alert('Parse error:\n\n'+e.message); console.error(e); }
}

document.getElementById('paletteSelect').addEventListener('change', () => { if (chartObj) parseAndDraw(); });
window.addEventListener('resize', () => {
  if (document.getElementById('card').style.display !== 'none') {
    applyLayout();
    const vb = document.getElementById('verdictBadge');
    if (vb.textContent) applyVerdictPos(vb);
  }
});

function downloadImage() {
  const card = document.getElementById('card');
  card.style.overflow = 'hidden';
  html2canvas(card, { scale: 3, backgroundColor: '#ffffff', useCORS: true })
    .then(canvas => {
      card.style.overflow = '';
      const a = document.createElement('a');
      a.download = 'qpAdm_chart.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
}
</script>
</body>
</html>