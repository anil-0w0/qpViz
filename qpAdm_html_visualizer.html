<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>qpAdm Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,400&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh; background: #111; font-family: 'Roboto', sans-serif;
      color: #e8e8e8; display: flex; flex-direction: column;
      align-items: center; padding: 28px 20px 48px; gap: 20px;
    }
    .app-header { width: 100%; max-width: 1000px; display: flex; align-items: baseline; gap: 12px; }
    .app-title  { font-size: 1.7rem; font-weight: 700; color: #fff; letter-spacing: -0.01em; }
    .app-subtitle { font-size: 0.7rem; font-weight: 500; color: #444; letter-spacing: 0.14em; text-transform: uppercase; }
    .input-panel { width: 100%; max-width: 1000px; display: flex; flex-direction: column; gap: 10px; }
    textarea { width: 100%; height: 150px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #c8c8c8; font-family: monospace; font-size: 11px; line-height: 1.65; padding: 12px 14px; resize: vertical; outline: none; }
    textarea:focus { border-color: #444; }
    textarea::placeholder { color: #333; }
    .controls-row, .social-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .social-field { display: flex; align-items: center; gap: 6px; }
    .social-field label { font-size: 10px; font-weight: 700; color: #444; text-transform: uppercase; letter-spacing: 0.1em; white-space: nowrap; }
    .social-field input { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 6px 9px; width: 120px; outline: none; }
    .social-field input:focus { border-color: #444; }
    .btn { padding: 8px 18px; border: none; border-radius: 3px; font-size: 13px; font-weight: 600; cursor: pointer; }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-dl { background: #2563eb; color: #fff; display: none; }
    .btn-dl:hover { background: #1d4ed8; }
    select { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 8px 10px; cursor: pointer; outline: none; }
    #formatBadge { display: none; font-size: 10px; font-weight: 700; padding: 4px 10px; border-radius: 2px; background: #0d2b18; color: #4ade80; letter-spacing: 0.07em; text-transform: uppercase; }
    #formatBadge.raw { background: #2b1800; color: #fb923c; }

    /* ═══ CARD ═══ */
    #card {
      width: 100%; max-width: 1000px;
      /* aspect-ratio set from CARD.aspectRatio in JS */
      border-radius: 4px; display: none;
      position: relative; overflow: visible;
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
    }
    .card-bg { position: absolute; inset: 0; border-radius: 4px; z-index: 0; pointer-events: none; }

    /* ═══ HEADER ═══ */
    .card-header { position: absolute; top: 0; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; z-index: 2; }
    #cardTarget { width: 100%; }
    .stat-sep { color: #bbb; margin: 0 8px; }

    /* ═══ PASS/FAIL — colours and geometry both from JS config ═══ */
    .verdict-badge { position: absolute; border: none; border-radius: 0; text-transform: uppercase; z-index: 3; }

    /* ═══ DONUT ═══ */
    #donutWrap { position: absolute; z-index: 10; }
    #donutWrap canvas { width: 100% !important; height: 100% !important; display: block; }

    /* ═══ INFO PANEL ═══ */
    .info-col { position: absolute; display: flex; flex-direction: column; justify-content: center; gap: 10px; min-width: 0; z-index: 2; }

    /* ═══ TABLES — structural skeleton; colours/borders from TABLE_STYLE ═══ */
    .data-box   { overflow: hidden; }
    .data-table { width: 100%; border-collapse: collapse; table-layout: fixed; }

    /* ── Column width control (sources table) ── */
    .col-sw-col   { width: 40px;  }
    .col-name-col { width: auto;  }
    .col-data-col { width: 220px; }

    /* Column base styles */
    .col-sw   { vertical-align: middle; text-align: left; }
    .col-name { vertical-align: middle; overflow: visible; white-space: normal; word-break: normal; overflow-wrap: normal; }
    .col-data { vertical-align: middle; }

    .swatch   { display: inline-block; vertical-align: middle; flex-shrink: 0; }
    .pop-name { vertical-align: middle; hyphens: none; line-height: 1.35; }

    /* Outgroups */
    .outgroups-td { white-space: normal; word-break: break-word; overflow-wrap: break-word; }

    /* Watermark */
    .watermark { position: absolute; bottom: 8px; right: 12px; z-index: 5; }
  </style>
</head>
<body>

<div class="app-header">
  <h1 class="app-title">qpAdm Visualizer</h1>
  <span class="app-subtitle">Admixture Chart Generator</span>
</div>

<div class="input-panel">
  <textarea id="qpadmText" placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG: full qpAdm output (left pops / right pops / best coefficients / std. errors / f4rank)
SUMMARY:  Target: X | Weights: PopA - 43.8% SE: 3.78% Z: 11.57 | P value: 0.15 | chisq: 8.04 | Rights: …"></textarea>
  <div class="controls-row">
    <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
    <select id="paletteSelect">
      <option value="0">qpAdm Classic (blue–green–red)</option>
      <option value="1">ColorBrewer Set1</option>
      <option value="2">Tableau (analytics)</option>
      <option value="3">Dark2 (high contrast)</option>
      <option value="4">Earth / Archaeogenetics</option>
      <option value="5">Soft Modern</option>
      <option value="6">Greyscale High Contrast</option>
      <option value="7">Greyscale Journal</option>
      <option value="8">Greyscale Soft</option>
      <option value="9">Blue Scale</option>
      <option value="10">Green Scale</option>
    </select>
    <span id="formatBadge"></span>
    <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ Download PNG</button>
  </div>
  <div class="social-row">
    <div class="social-field"><label>Telegram</label><input type="text" id="telegramInput" placeholder="@username"></div>
    <div class="social-field"><label>X / Twitter</label><input type="text" id="xInput" placeholder="@username"></div>
    <div class="social-field"><label>Discord</label><input type="text" id="discordInput" placeholder="username"></div>
  </div>
</div>

<!-- CARD -->
<div id="card">
  <div class="card-bg" id="cardBg"></div>
  <div class="card-header" id="cardHeader">
    <div id="cardTarget"></div>
    <div id="statLine"></div>
    <div class="verdict-badge" id="verdictBadge"></div>
  </div>
  <div id="donutWrap"><canvas id="donutChart"></canvas></div>
  <div class="info-col" id="infoCol">
    <div class="data-box" id="sourcesBox">
      <table class="data-table" id="sourcesTable">
        <colgroup>
          <col class="col-sw-col">
          <col class="col-name-col">
          <col class="col-data-col">
        </colgroup>
        <thead id="sourcesHead"></thead>
        <tbody id="sourcesBody"></tbody>
      </table>
    </div>
    <div class="data-box" id="outgroupsBox" style="display:none;">
      <table class="data-table" id="outgroupsTable">
        <thead><tr><th id="hdrOutgroups"></th></tr></thead>
        <tbody><tr><td class="outgroups-td" id="outgroupsTd"></td></tr></tbody>
      </table>
    </div>
  </div>
  <div class="watermark" id="watermark"></div>
</div>

<script>
/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  CARD  —  global card appearance                                         ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const CARD = {
  bgColor:     '#ffffff',    /* card background colour                        */
  aspectRatio: '16 / 10.5', /* CSS aspect-ratio string                       */
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  LAYOUT  —  positions as % of card width (X) or card height (Y)         ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const LAYOUT = {
  donutCenterX:   23,
  donutCenterY:   55,
  donutDiameter:  43,

  panelLeft:       48,
  panelTop:        18,
  panelRight:       2,
  panelBottom:      3,
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  VERDICT BADGE — position, size, colours                                ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const VERDICT_POS = {
  anchorX:    98,
  anchorY:    3,
  anchor:     'top-right',
  minWidth:   0,
  minHeight:  0,
  paddingV:   8,
  paddingH:   8,
  textAlign:  'center',

  passBg:     '#f3fefd',
  passText:   '#3a9063',

  weakBg:     '#fefce8',
  weakText:   '#ca8a04',

  failBg:     '#FBE9E9',
  failText:   '#dc2626',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  VERDICT THRESHOLDS — tune without touching render logic                ║
   ║                                                                          ║
   ║  pValueFail      p  < this  → FAIL                                      ║
   ║  minZFail        |Z| < this → FAIL  (uses absolute value — negative Z   ║
   ║                               from overfit models is caught correctly)  ║
   ║  minWeightFail   any weight < this % → FAIL  (catches negative weights) ║
   ║  maxRelSEFail    SE/weight > this → FAIL                                ║
   ║  minWtForSE      components < this % are SKIPPED for SE check           ║
   ║                  (prevents Infinity from tiny-but-legitimate components) ║
   ║                                                                          ║
   ║  STRONG PASS — all three must hold:                                     ║
   ║  minZStrong      all |Z| ≥ this                                          ║
   ║  maxRelSEStrong  SE/weight ≤ this                                        ║
   ║  maxSourcesStrong  number of sources ≤ this                             ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const VERDICT_CFG = {
  pValueFail:        0.05,
  minZFail:          2.0,
  minWeightFail:    -5,
  maxRelSEFail:      1.5,
  minWtForSE:        2,      /* % — skip SE ratio check below this weight    */

  minZStrong:        3.0,
  maxRelSEStrong:    0.5,
  maxSourcesStrong:  4,
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  Z-SCORE TIER COLOURS  —  fully configurable from JS                    ║
   ║  Applied via inline style; overrides any CSS .z-good / .z-mid / .z-bad  ║
   ║  zGood  |Z| ≥ CFG.zGoodMin                                              ║
   ║  zMid   CFG.zMidMin ≤ |Z| < CFG.zGoodMin                               ║
   ║  zBad   |Z| < CFG.zMidMin                                               ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const Z_COLORS = {
  zGood: '#16a34a',
  zMid:  '#ca8a04',
  zBad:  '#dc2626',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  TABLE STYLE                                                             ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const TABLE_STYLE = {
  boxBorderWidth:    '1.5px',
  boxBorderColor:    '#d1d5db',
  boxBorderRadius:   '2px',

  headerBg:          '#f3f4f6',
  headerBorderWidth: '1.5px',
  headerBorderColor: '#d1d5db',

  rowBorderWidth:    '1px',
  rowBorderColor:    '#e5e7eb',

  cellBg:     'transparent',
  evenRowBg:  'transparent',
  oddRowBg:   'transparent',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  DONUT CONFIG                                                            ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const CFG = {
  donutCutout:      '65%',
  donutBorderW:     2,
  donutBorderC:     '#000000',
  donutHoverOff:    14,
  donutClockwise:   true,
  donutStartAngle:  0,
  zGoodMin:         3,
  zMidMin:          2,
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  SWATCH                                                                  ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const SWATCH = {
  width:   '29px',
  height:  '23px',
  radius:  '0px',
  border:  '1.8px solid #000',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  TYPOGRAPHY                                                              ║
   ║                                                                          ║
   ║  NOTE: 'Cascadia Code' and 'Inter' are not loaded from Google Fonts     ║
   ║  and will fall back to system fonts. To load them, add to <head>:       ║
   ║    Cascadia Code → no Google Fonts equivalent; use 'Roboto Mono'        ║
   ║    Inter → https://fonts.googleapis.com/css2?family=Inter               ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const TYPOGRAPHY = {

  target: {
    font:          'Roboto, sans-serif',
    fontSize:      'clamp(40px, 4.5vw, 60px)',
    fontWeight:    900,
    fontStyle:     'normal',
    color:         '#0a0a0a',
    letterSpacing: '-0.02em',
    lineHeight:    '1.05',
    align:         'center',
  },

  stat: {
    font:          'Cascadia Code, sans-serif',
    fontSize:      'clamp(18px, 2.0vw, 30px)',
    fontWeight:    400,
    fontStyle:     'normal',
    color:         '#555555',
    letterSpacing: '0.01em',
    lineHeight:    '1.3',
    align:         'center',
    marginTop:     '2px',
  },

  headerPadding: {
    top:    '10px',
    sides:  '24px',
    bottom: '0px',
  },

  verdict: {
    font:          'Inter, sans-serif',
    fontSize:      'clamp(10px, 1.9vw, 18px)',
    fontWeight:    800,
    fontStyle:     'normal',
    letterSpacing: '0.14em',
  },

  sourcesHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Coeff \u00B1 SE  (Z-score)',
    textTransform: 'uppercase',
  },

  sourcesName: {
    font:          'Roboto, sans-serif',
    fontSize:      '17px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    lineHeight:    '1.35',
    align:         'left',
  },

  sourcesCoeff: {
    font:          'Roboto, sans-serif',
    fontSize:      '17px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    align:         'left',
  },

  /* zSepPx   — px gap between coeff block and the (Z: …) bracket
     zPrefix  — text inside the bracket before the number
     zGap     — kept for API compatibility; not used in rendering            */
  sourcesZ: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    700,
    fontStyle:     'normal',
    letterSpacing: '0',
    zPrefix:       'Z:\u2009',
    zSepPx:        8,
    zGap:          '3px',
  },

  sourcesColon: {
    colonText:   ': ',
    colonFont:   'Roboto, sans-serif',
    colonColor:  '#111111',
  },

  /* Per-row overrides — { index: N, nameColor: '…', coeffFontWeight: 700, … }
     Valid prefixes: name* | coeff* | z*                                     */
  sourcesRowOverrides: [
    // { index: 0, nameColor: '#e63946' },
  ],

  outgroupsHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Right (Outgroups)',
    textTransform: 'uppercase',
  },

  outgroupsCell: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0',
    lineHeight:    '1.6',
    align:         'left',
  },

  watermark: {
    font:          'Roboto, sans-serif',
    fontSize:      '9px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#c0cad6',
    letterSpacing: '0.05em',
  },
};

/* ══ COLOR PALETTES (curated, ≤6 components) ═══════════════════════════════ */
const colorPalettes = [
  /* 0 — qpAdm Classic (blue / green / red) */
  ['#4c72b0', '#55a868', '#c44e52', '#8172b2', '#ccb974', '#64b5cd'],
  /* 1 — ColorBrewer Set1 (high contrast, canonical) */
  ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'],
  /* 2 — Tableau 10 (trimmed, analytics standard) */
  ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'],
  /* 3 — Dark2 (strong separation, presentations) */
  ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#a6761d'],
  /* 4 — Archaeogenetics / Earth tones */
  ['#5b8c5a', '#4c6a92', '#c97c5d', '#b1a44c', '#7a4a6e', '#6b705c'],
  /* 5 — Soft Modern (low saturation, papers) */
  ['#457b9d', '#2a9d8f', '#e63946', '#f4a261', '#264653', '#b5838d'],
  /* 6 — Greyscale High Contrast (print-safe) */
  ['#111111', '#2f2f2f', '#555555', '#7a7a7a', '#a0a0a0', '#cfcfcf'],
  /* 7 — Greyscale (balanced, journal figures) */
  ['#1a1a1a', '#3a3a3a', '#5a5a5a', '#7a7a7a', '#9a9a9a', '#bababa'],
  /* 8 — Greyscale (soft, background-friendly) */
  ['#2b2b2b', '#4b4b4b', '#6b6b6b', '#8b8b8b', '#ababab', '#d0d0d0'],
  /* 9 — Blue-scale (population structure friendly) */
  ['#08306b', '#08519c', '#2171b5', '#4292c6', '#6baed6', '#9ecae1'],
  /* 10 — Green-scale (ASI/AASI-heavy models) */
  ['#00441b', '#006d2c', '#238b45', '#41ab5d', '#74c476', '#a1d99b'],
];

/* ══ STATE ══════════════════════════════════════════════════════════════════ */
let chartObj = null;

/* ══ UTILITIES ══════════════════════════════════════════════════════════════ */

function applyT(el, t) {
  if (!el || !t) return;
  if (t.font)          el.style.fontFamily    = t.font;
  if (t.fontSize)      el.style.fontSize      = t.fontSize;
  if (t.fontWeight)    el.style.fontWeight    = t.fontWeight;
  if (t.fontStyle)     el.style.fontStyle     = t.fontStyle;
  if (t.color)         el.style.color         = t.color;
  if (t.letterSpacing) el.style.letterSpacing = t.letterSpacing;
  if (t.lineHeight)    el.style.lineHeight    = t.lineHeight;
  if (t.align)         el.style.textAlign     = t.align;
}

function applyTableStyle(boxEl) {
  if (!boxEl) return;
  const ts = TABLE_STYLE;
  boxEl.style.border       = `${ts.boxBorderWidth} solid ${ts.boxBorderColor}`;
  boxEl.style.borderRadius = ts.boxBorderRadius;
}

function applyLayout() {
  const card = document.getElementById('card');
  const wrap = document.getElementById('donutWrap');
  const info = document.getElementById('infoCol');
  const cW = card.offsetWidth, cH = card.offsetHeight;
  const d  = (LAYOUT.donutDiameter / 100) * cW;
  const cx = (LAYOUT.donutCenterX  / 100) * cW;
  const cy = (LAYOUT.donutCenterY  / 100) * cH;
  wrap.style.width  = d + 'px'; wrap.style.height = d + 'px';
  wrap.style.left   = (cx - d / 2) + 'px';
  wrap.style.top    = (cy - d / 2) + 'px';
  info.style.left   = ((LAYOUT.panelLeft   / 100) * cW) + 'px';
  info.style.top    = ((LAYOUT.panelTop    / 100) * cH) + 'px';
  info.style.right  = ((LAYOUT.panelRight  / 100) * cW) + 'px';
  info.style.bottom = ((LAYOUT.panelBottom / 100) * cH) + 'px';
}

/* 2-pass: apply styles → measure → position */
function applyVerdictPos(vb, verdictType) {
  const card = document.getElementById('card');
  const cW = card.offsetWidth, cH = card.offsetHeight;
  const vp = VERDICT_POS;

  applyT(vb, TYPOGRAPHY.verdict);

  switch (verdictType) {
    case 'pass': vb.style.background = vp.passBg; vb.style.color = vp.passText; break;
    case 'weak': vb.style.background = vp.weakBg; vb.style.color = vp.weakText; break;
    default:     vb.style.background = vp.failBg; vb.style.color = vp.failText;
  }

  vb.style.padding   = `${vp.paddingV}px ${vp.paddingH}px`;
  vb.style.textAlign = vp.textAlign;
  if (vp.minWidth  > 0) vb.style.minWidth  = vp.minWidth  + 'px';
  if (vp.minHeight > 0) vb.style.minHeight = vp.minHeight + 'px';

  /* Pass 1: measure */
  vb.style.visibility = 'hidden';
  vb.style.left = '0'; vb.style.top = '0';
  vb.style.right = ''; vb.style.bottom = '';
  const bW = vb.offsetWidth, bH = vb.offsetHeight;
  vb.style.visibility = '';

  /* Pass 2: position */
  const ax = (vp.anchorX / 100) * cW;
  const ay = (vp.anchorY / 100) * cH;
  const a  = vp.anchor || 'top-right';
  const hP = a.includes('left') ? 0 : a.includes('right') ? 1 : 0.5;
  const vP = a.includes('bottom') ? 1 : 0;
  vb.style.left   = (ax - hP * bW) + 'px';
  vb.style.top    = (ay - vP * bH) + 'px';
  vb.style.right  = '';
  vb.style.bottom = '';
}

/* ── Update swatches + donut on palette change (no full re-render) ── */
function updateSourceColors(pal) {
  document.querySelectorAll('#sourcesBody .swatch').forEach((sw, i) => {
    sw.style.background = i < pal.length ? pal[i] : '#cccccc';
  });
}

function softBreak(s) { return s.replace(/([_.\-])/g, '$1<wbr>'); }

/* ── Z-score colour resolved from Z_COLORS config (not CSS class) ── */
function zColor(z) {
  /* BUG FIX: use Math.abs so negative Z-scores (overfit models) are
     classified correctly — a Z of -5 is a strong signal, not z-bad. */
  const absZ = Math.abs(z);
  return absZ >= CFG.zGoodMin ? Z_COLORS.zGood
       : absZ >= CFG.zMidMin  ? Z_COLORS.zMid
       : Z_COLORS.zBad;
}

function mergeRow(i) {
  const base = {
    nameFont:           TYPOGRAPHY.sourcesName.font,
    nameFontSize:       TYPOGRAPHY.sourcesName.fontSize,
    nameFontWeight:     TYPOGRAPHY.sourcesName.fontWeight,
    nameFontStyle:      TYPOGRAPHY.sourcesName.fontStyle      || 'normal',
    nameColor:          TYPOGRAPHY.sourcesName.color,
    nameLetterSpacing:  TYPOGRAPHY.sourcesName.letterSpacing  || '0',
    nameLineHeight:     TYPOGRAPHY.sourcesName.lineHeight      || '1.35',
    nameAlign:          TYPOGRAPHY.sourcesName.align,
    coeffFont:          TYPOGRAPHY.sourcesCoeff.font,
    coeffFontSize:      TYPOGRAPHY.sourcesCoeff.fontSize,
    coeffFontWeight:    TYPOGRAPHY.sourcesCoeff.fontWeight,
    coeffFontStyle:     TYPOGRAPHY.sourcesCoeff.fontStyle     || 'normal',
    coeffColor:         TYPOGRAPHY.sourcesCoeff.color,
    coeffLetterSpacing: TYPOGRAPHY.sourcesCoeff.letterSpacing || '0',
    coeffAlign:         TYPOGRAPHY.sourcesCoeff.align,
    zFont:              TYPOGRAPHY.sourcesZ.font,
    zFontSize:          TYPOGRAPHY.sourcesZ.fontSize,
    zFontWeight:        TYPOGRAPHY.sourcesZ.fontWeight,
    zFontStyle:         TYPOGRAPHY.sourcesZ.fontStyle         || 'normal',
    zLetterSpacing:     TYPOGRAPHY.sourcesZ.letterSpacing     || '0',
    zGap:               TYPOGRAPHY.sourcesZ.zGap,
  };
  const ov = TYPOGRAPHY.sourcesRowOverrides.find(r => r.index === i);
  return ov ? Object.assign({}, base, ov) : base;
}

/* ── Verdict logic — reads from VERDICT_CFG, not hardcoded ── */
function resolveVerdict(weights, sesPct, zScores, pValue) {
  const c = VERDICT_CFG;

  const minAbsZ   = Math.min(...zScores.map(z => Math.abs(z)));
  const minWeight = Math.min(...weights);

  /* BUG FIX: skip SE ratio check for components below minWtForSE %.
     Without this, a 0.8% legitimate component (weight ≤ 1) produces
     Infinity which always triggers FAIL — incorrect behaviour.         */
  const relSEs = sesPct
    .map((se, i) => weights[i] >= c.minWtForSE ? se / weights[i] : null)
    .filter(v => v !== null);
  const maxRelSE = relSEs.length > 0 ? Math.max(...relSEs) : 0;

  if (
    pValue    <  c.pValueFail    ||
    minAbsZ   <  c.minZFail      ||
    minWeight <  c.minWeightFail ||
    maxRelSE  >  c.maxRelSEFail
  ) return 'fail';

  if (
    minAbsZ        >= c.minZStrong       &&
    maxRelSE       <= c.maxRelSEStrong   &&
    weights.length <= c.maxSourcesStrong
  ) return 'pass';

  return 'weak';
}

/* ══ PARSERS ════════════════════════════════════════════════════════════════ */

function isRawFormat(t) { return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t); }

function parseRaw(text) {
  const lines = text.split('\n');
  const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
  if (li < 0) throw new Error('"left pops:" not found');
  const lp = [];
  for (let i = li+1; i < lines.length; i++) {
    const l = lines[i].trim();
    if (!l || /^right pops/i.test(l)) break;
    const m = l.match(/^(\S+)\s+\d+/); if (m) lp.push(m[1]);
  }
  if (lp.length < 2) throw new Error('Need target + ≥1 source in left pops');
  const target = lp[0], sources = lp.slice(1);

  const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
  const rp = [];
  if (ri >= 0) {
    for (let i = ri+1; i < lines.length; i++) {
      const l = lines[i].trim();
      if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
      const m = l.match(/^(\S+)\s+\d+/); if (m) rp.push(m[1]);
    }
  }

  let pValue = NaN, chisq = NaN;
  const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
  if (ci >= 0) {
    for (let i = ci+1; i < Math.min(ci+6, lines.length); i++) {
      const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
    }
  }
  if (isNaN(pValue)) {
    for (const l of lines) {
      const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
    }
  }
  if (isNaN(pValue)) throw new Error('Could not parse p-value');

  const cl = lines.find(l => /best coefficients:/.test(l));
  if (!cl) throw new Error('"best coefficients:" not found');
  const coeffs = cl.replace('best coefficients:','').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (coeffs.length !== sources.length) throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);

  const sl = lines.find(l => /std\.\s*errors:/.test(l));
  if (!sl) throw new Error('"std. errors:" not found');
  const ses = sl.replace(/std\.\s*errors:/,'').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (ses.length !== sources.length) throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);

  const tot = coeffs.reduce((a,b)=>a+b,0);
  return { target, sources,
    weights: coeffs.map(c=>(c/tot)*100), sesPct: ses.map(s=>s*100),
    zScores: coeffs.map((c,i)=>ses[i]>0?c/ses[i]:0),
    pValue, chisq, outgroups: rp.join(', ') };
}

function parseSummary(text) {
  const lines = text.split('\n').map(l=>l.trim()).filter(Boolean);
  const tl = lines.find(l=>l.startsWith('Target:'));
  if (!tl) throw new Error('Target line not found');
  const target = tl.replace('Target:','').trim();
  const ws = lines.findIndex(l=>l.startsWith('Weights:'));
  if (ws < 0) throw new Error('Weights section not found');
  const pvl = lines.find(l=>l.startsWith('P value:')), chl = lines.find(l=>l.startsWith('chisq:'));
  if (!pvl) throw new Error('P value not found'); if (!chl) throw new Error('chisq not found');
  const pValue = parseFloat(pvl.replace('P value:','').trim());
  const chisq  = parseFloat(chl.replace('chisq:','').trim());
  const rgl    = lines.find(l=>l.startsWith('Rights:'));
  const outgroups = rgl ? rgl.replace('Rights:','').trim() : '';
  const sources=[],weights=[],sesPct=[],zScores=[];
  for (let i=ws+1; i<lines.length; i++) {
    const l = lines[i];
    if (/^(P value:|chisq:|Rights:)/.test(l)) break;
    const m = l.match(/^(.+?)\s*-\s*([\d.]+)%\s*SE:\s*([\d.]+)%\s*Z:\s*([-\d.]+)/);
    if (m) { sources.push(m[1].trim()); weights.push(parseFloat(m[2])); sesPct.push(parseFloat(m[3])); zScores.push(parseFloat(m[4])); }
  }
  if (!sources.length) throw new Error('No populations found');
  const tot = weights.reduce((a,b)=>a+b,0);
  return { target, sources, weights: weights.map(w=>(w/tot)*100), sesPct, zScores, pValue, chisq, outgroups };
}

/* ══ MAIN RENDER ════════════════════════════════════════════════════════════ */
function parseAndDraw() {
  const text = document.getElementById('qpadmText').value.trim();
  document.getElementById('card').style.display        = 'none';
  document.getElementById('downloadBtn').style.display = 'none';

  try {
    let parsed, fmtTxt, fmtCls;
    if (isRawFormat(text)) { parsed = parseRaw(text);     fmtTxt = '⚙ Raw log'; fmtCls = 'raw'; }
    else                   { parsed = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = ''; }

    const fmtBadge = document.getElementById('formatBadge');
    fmtBadge.textContent = fmtTxt; fmtBadge.className = fmtCls; fmtBadge.style.display = 'inline-block';

    const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;

    if (sources.length > 6) {
      console.warn('qpAdm model uses >6 sources — interpretability reduced. Excess sources rendered in grey (#cccccc).');
    }

    /* ── Card ── */
    const cardEl = document.getElementById('card');
    cardEl.style.background  = CARD.bgColor;
    cardEl.style.aspectRatio = CARD.aspectRatio;
    document.getElementById('cardBg').style.background = CARD.bgColor;

    /* ── Header padding ── */
    const hp = TYPOGRAPHY.headerPadding;
    document.getElementById('cardHeader').style.padding = `${hp.top} ${hp.sides} ${hp.bottom} ${hp.sides}`;

    /* ── Target ── */
    const tEl = document.getElementById('cardTarget');
    tEl.textContent = 'Target: ' + target;
    applyT(tEl, TYPOGRAPHY.target);

    /* ── Stat line ── */
    const pd   = pValue < 0.0001 ? pValue.toExponential(4) : parseFloat(pValue.toPrecision(7)).toString();
    const slEl = document.getElementById('statLine');
    slEl.innerHTML = `χ² = ${chisq.toFixed(2)}<span class="stat-sep"> / </span>p = ${pd}`;
    applyT(slEl, TYPOGRAPHY.stat);
    slEl.style.marginTop = TYPOGRAPHY.stat.marginTop || '2px';

    /* ── Show card (needed before any measurements) ── */
    cardEl.style.display = 'block';

    /* ── Verdict ── */
    const verdictType = resolveVerdict(weights, sesPct, zScores, pValue);
    const verdictText = { pass: 'PASS', weak: 'PASS*', fail: 'FAIL' }[verdictType];
    const vb = document.getElementById('verdictBadge');
    vb.textContent     = verdictText;
    vb.dataset.verdict = verdictType;   /* stored for resize handler */
    applyVerdictPos(vb, verdictType);

    /* ── Layout ── */
    applyLayout();

    /* ── Table borders ── */
    applyTableStyle(document.getElementById('sourcesBox'));
    applyTableStyle(document.getElementById('outgroupsBox'));

    /* ── Colors ── */
    const pidx   = parseInt(document.getElementById('paletteSelect').value);
    const pal    = colorPalettes[pidx] || colorPalettes[0];
    const colors = sources.map((_, i) => i < pal.length ? pal[i] : '#cccccc');

    /* ── Donut ── */
    const ctx = document.getElementById('donutChart').getContext('2d');
    if (chartObj) chartObj.destroy();
    chartObj = new Chart(ctx, {
      type: 'doughnut',
      data: { labels: sources, datasets: [{
        data: weights,
        backgroundColor: colors, hoverBackgroundColor: colors,
        borderColor: CFG.donutBorderC, hoverBorderColor: CFG.donutBorderC,
        borderWidth: CFG.donutBorderW, hoverBorderWidth: CFG.donutBorderW,
        hoverOffset: CFG.donutHoverOff,
      }]},
      options: {
        responsive: true, cutout: CFG.donutCutout,
        rotation: CFG.donutStartAngle,
        circumference: CFG.donutClockwise ? 360 : -360,
        layout: { padding: CFG.donutHoverOff },
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` } }
        },
        animation: { animateRotate: true, duration: 550 }
      }
    });

    /* ══ SOURCES TABLE ══════════════════════════════════════════════════════
       Header: colspan=3 → always centred over full table width.
       Column widths enforced by <colgroup> in HTML.
       ═══════════════════════════════════════════════════════════════════════ */
    const ts  = TABLE_STYLE;
    const sh  = TYPOGRAPHY.sourcesHeader;
    const zT  = TYPOGRAPHY.sourcesZ;
    const sc  = TYPOGRAPHY.sourcesColon;
    const swColW = (parseInt(SWATCH.width) + 16) + 'px';

    document.getElementById('sourcesHead').innerHTML = `
      <tr>
        <th colspan="3" style="
          font-family:${sh.font};font-size:${sh.fontSize};
          font-weight:${sh.fontWeight};font-style:${sh.fontStyle||'normal'};
          color:${sh.color};letter-spacing:${sh.letterSpacing};
          line-height:${sh.lineHeight};text-align:${sh.align};
          text-transform:${sh.textTransform||'uppercase'};
          background:${ts.headerBg};
          border-bottom:${ts.headerBorderWidth} solid ${ts.headerBorderColor};
          padding:5px 10px;white-space:nowrap;
        ">${sh.text}</th>
      </tr>`;

    let srcHTML = '';
    sources.forEach((pop, i) => {
      const rs     = mergeRow(i);
      const z      = zScores[i];
      const zCol   = zColor(z);            /* from Z_COLORS config, uses Math.abs */
      const rowBg  = (i % 2 === 0) ? ts.evenRowBg : ts.oddRowBg;
      const cellBg = ts.cellBg !== 'transparent' ? ts.cellBg : rowBg;

      /* BUG FIX: skip border on last row instead of post-hoc regex.
         The old regex only removed the border from the 3rd <td>; the
         swatch and name cells in the last row still had it.             */
      const isLast = i === sources.length - 1;
      const rowBdr = isLast ? '' : `border-bottom:${ts.rowBorderWidth} solid ${ts.rowBorderColor};`;

      const zHtml = `<span style="
          font-family:${rs.zFont};font-size:${rs.zFontSize};
          font-weight:${rs.zFontWeight};font-style:${rs.zFontStyle};
          letter-spacing:${rs.zLetterSpacing};color:${zCol};
          white-space:nowrap;vertical-align:baseline;
        ">(${zT.zPrefix}${z.toFixed(2)})</span>`;

      const zSepHtml  = `<span style="display:inline-block;width:${zT.zSepPx}px;"></span>`;
      const colonHtml = `<span style="font-family:${sc.colonFont};color:${sc.colonColor};white-space:pre;">${sc.colonText}</span>`;
      const coeffHtml = `<span style="
          font-family:${rs.coeffFont};font-size:${rs.coeffFontSize};
          font-weight:${rs.coeffFontWeight};font-style:${rs.coeffFontStyle};
          color:${rs.coeffColor};letter-spacing:${rs.coeffLetterSpacing};
          white-space:nowrap;vertical-align:baseline;
        ">${weights[i].toFixed(1)}% \u00B1 ${sesPct[i].toFixed(2)}%</span>`;

      const dataHtml = `${colonHtml}${coeffHtml}${zSepHtml}${zHtml}`;

      srcHTML += `<tr style="background:${rowBg};">
        <td class="col-sw"   style="width:${swColW};padding:5px 0 5px 10px !important;vertical-align:middle;${rowBdr}background:${cellBg};">
          <span class="swatch" style="background:${colors[i]};width:${SWATCH.width};height:${SWATCH.height};border-radius:${SWATCH.radius};border:${SWATCH.border};"></span>
        </td>
        <td class="col-name" style="text-align:${rs.nameAlign};padding:5px 4px !important;vertical-align:middle;${rowBdr}background:${cellBg};">
          <span class="pop-name" style="font-family:${rs.nameFont};font-size:${rs.nameFontSize};font-weight:${rs.nameFontWeight};font-style:${rs.nameFontStyle};color:${rs.nameColor};letter-spacing:${rs.nameLetterSpacing};line-height:${rs.nameLineHeight};">${softBreak(pop)}</span>
        </td>
        <td class="col-data" style="text-align:${rs.coeffAlign};white-space:nowrap;padding:5px 10px;vertical-align:middle;${rowBdr}background:${cellBg};">${dataHtml}</td>
      </tr>`;
    });
    document.getElementById('sourcesBody').innerHTML = srcHTML;

    /* ── Outgroups ── */
    const ogBox = document.getElementById('outgroupsBox');
    const ogTd  = document.getElementById('outgroupsTd');
    const ogH   = document.getElementById('hdrOutgroups');
    const ogh   = TYPOGRAPHY.outgroupsHeader;
    const ogc   = TYPOGRAPHY.outgroupsCell;
    if (outgroups) {
      ogH.textContent = ogh.text;
      applyT(ogH, ogh);
      ogH.style.textTransform = ogh.textTransform || 'uppercase';
      ogH.style.padding       = '5px 10px';
      ogH.style.background    = ts.headerBg;
      ogH.style.borderBottom  = `${ts.headerBorderWidth} solid ${ts.headerBorderColor}`;
      applyT(ogTd, ogc);
      ogTd.style.padding    = '5px 10px';
      ogTd.style.background = ts.cellBg;
      ogTd.textContent      = outgroups;
      ogBox.style.display   = 'block';
    } else {
      ogBox.style.display = 'none';
    }

    /* ── Watermark ── */
    const wEl = document.getElementById('watermark');
    applyT(wEl, TYPOGRAPHY.watermark);
    const tg = document.getElementById('telegramInput').value.trim();
    const xw = document.getElementById('xInput').value.trim();
    const dc = document.getElementById('discordInput').value.trim();
    const pts = [];
    if (tg) pts.push('TG: '+tg);
    if (xw) pts.push('X: '+xw);
    if (dc) pts.push('DC: '+dc);
    wEl.textContent = pts.join('  \u00B7  ');

    document.getElementById('downloadBtn').style.display = 'inline-block';

  } catch(e) { alert('Parse error:\n\n'+e.message); console.error(e); }
}

/* ── Palette change: update donut + swatches without full re-render ── */
document.getElementById('paletteSelect').addEventListener('change', () => {
  if (!chartObj) return;
  const pidx   = parseInt(document.getElementById('paletteSelect').value);
  const pal    = colorPalettes[pidx] || colorPalettes[0];
  const labels = chartObj.data.labels;
  const colors = labels.map((_, i) => i < pal.length ? pal[i] : '#cccccc');

  chartObj.data.datasets[0].backgroundColor      = colors;
  chartObj.data.datasets[0].hoverBackgroundColor = colors;
  chartObj.update();

  updateSourceColors(pal);
});

/* ── Resize ──
   BUG FIX: use vb.dataset.verdict (set during render) instead of
   checking vb.textContent === 'PASS' — that missed 'PASS*' entirely. */
window.addEventListener('resize', () => {
  if (document.getElementById('card').style.display === 'none') return;
  applyLayout();
  const vb = document.getElementById('verdictBadge');
  if (vb.textContent) applyVerdictPos(vb, vb.dataset.verdict || 'fail');
});

/* ── Download ── */
function downloadImage() {
  const card = document.getElementById('card');
  card.style.overflow = 'hidden';
  html2canvas(card, { scale: 3, backgroundColor: CARD.bgColor, useCORS: true })
    .then(canvas => {
      card.style.overflow = '';
      const a = document.createElement('a');
      a.download = 'qpAdm_chart.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
}
</script>
</body>
</html>