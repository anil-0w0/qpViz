<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>qpAdm Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,400&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>

    /* ╔══════════════════════════════════════════════════════════════╗
       ║  DESIGN TOKENS — edit anything here to restyle the card     ║
       ╚══════════════════════════════════════════════════════════════╝ */
    :root {
      /* ── Fonts (swap family name to change typeface) ── */
      --font-target:       'Roboto', sans-serif;   /* large population name */
      --font-stat:         'Roboto', sans-serif;   /* χ² / p line           */
      --font-verdict:      'Roboto', sans-serif;   /* PASS / FAIL badge     */
      --font-table-header: 'Roboto', sans-serif;   /* column headers        */
      --font-pop-name:     'Roboto', sans-serif;   /* source population names */
      --font-coeff:        'Roboto', sans-serif;   /* coeff ± SE values     */
      --font-z:            'Roboto', sans-serif;   /* Z-score values        */
      --font-outgroup:     'Roboto', sans-serif;   /* outgroup text         */
      --font-watermark:    'Roboto', sans-serif;   /* social watermark      */
      --font-ui:           'Roboto', sans-serif;   /* app chrome            */

      /* ── Font weights ── */
      --fw-target:         900;
      --fw-stat:           400;
      --fw-verdict:        700;
      --fw-table-header:   600;
      --fw-pop-name:       500;
      --fw-coeff:          400;
      --fw-z:              700;
      --fw-outgroup:       400;

      /* ── Font sizes (inside card) ── */
      --fs-target:         clamp(24px, 3.9vw, 46px);
      --fs-stat:           clamp(11px, 1.4vw,  17px);
      --fs-table-header:   clamp(8px,  0.82vw, 10px);
      --fs-pop-name:       clamp(10px, 1.05vw, 13px);
      --fs-coeff:          clamp(9px,  0.98vw, 12px);
      --fs-z:              clamp(9px,  0.98vw, 12px);
      --fs-verdict:        clamp(11px, 1.15vw, 14px);
      --fs-outgroup:       clamp(9px,  0.92vw, 11px);

      /* ── Letter spacing ── */
      --ls-target:         -0.02em;
      --ls-stat:            0.01em;
      --ls-table-header:    0.1em;
      --ls-verdict:         0.12em;

      /* ── Verdict badge colours ── */
      --pass-bg:           #dcfce7;   /* very light green fill */
      --pass-text:         #14532d;   /* dark green text       */
      --fail-bg:           #fee2e2;   /* very light red fill   */
      --fail-text:         #7f1d1d;   /* dark red text         */

      /* ── Z-score thresholds & colours ── */
      --z-good-min:        3;         /* Z ≥ 3   → green  */
      --z-mid-min:         2;         /* Z ≥ 2   → yellow */
                                      /* Z <  2  → red    */
      --z-good-color:      #16a34a;
      --z-mid-color:       #ca8a04;
      --z-bad-color:       #dc2626;

      /* ── Swatch (legend colour square) ── */
      --swatch-w:          18px;      /* width  */
      --swatch-h:          14px;      /* height */
      --swatch-radius:     0px;       /* 0 = sharp corners */
      --swatch-border:     1.5px solid #000;

      /* ── Table ── */
      --table-border:      1.5px solid #d1d5db;
      --row-sep:           1px solid #e5e7eb;
      --cell-pad-v:        6px;
      --cell-pad-h:        12px;
      --header-bg:         #f3f4f6;

      /* ── Card ── */
      --card-radius:       4px;
    }

    /* ╔══════════════════════════════════════════════════════════════╗
       ║  RESET & BODY                                               ║
       ╚══════════════════════════════════════════════════════════════╝ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background: #111;
      font-family: var(--font-ui);
      color: #e8e8e8;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 28px 20px 48px;
      gap: 20px;
    }

    /* ── APP HEADER ── */
    .app-header {
      width: 100%;
      max-width: 1000px;
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    .app-title {
      font-family: var(--font-ui);
      font-size: 1.7rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.01em;
    }
    .app-subtitle {
      font-size: 0.7rem;
      font-weight: 500;
      color: #444;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    /* ── INPUT PANEL ── */
    .input-panel {
      width: 100%;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    textarea {
      width: 100%;
      height: 150px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #c8c8c8;
      font-family: monospace;
      font-size: 11px;
      line-height: 1.65;
      padding: 12px 14px;
      resize: vertical;
      outline: none;
    }
    textarea:focus { border-color: #444; }
    textarea::placeholder { color: #333; }

    .controls-row, .social-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .social-field { display: flex; align-items: center; gap: 6px; }
    .social-field label {
      font-size: 10px;
      font-weight: 700;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      white-space: nowrap;
    }
    .social-field input {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #bbb;
      font-family: var(--font-ui);
      font-size: 12px;
      padding: 6px 9px;
      width: 120px;
      outline: none;
    }
    .social-field input:focus { border-color: #444; }

    .btn {
      padding: 8px 18px;
      border: none;
      border-radius: 3px;
      font-family: var(--font-ui);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-dl { background: #2563eb; color: #fff; display: none; }
    .btn-dl:hover { background: #1d4ed8; }

    select {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #bbb;
      font-family: var(--font-ui);
      font-size: 12px;
      padding: 8px 10px;
      cursor: pointer;
      outline: none;
    }
    #formatBadge {
      display: none;
      font-size: 10px;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 2px;
      background: #0d2b18;
      color: #4ade80;
      letter-spacing: 0.07em;
      text-transform: uppercase;
    }
    #formatBadge.raw { background: #2b1800; color: #fb923c; }

    /* ╔══════════════════════════════════════════════════════════════╗
       ║  16 : 12  OUTPUT CARD                                       ║
       ╚══════════════════════════════════════════════════════════════╝ */
    #card {
      width: 100%;
      max-width: 1000px;
      aspect-ratio: 16 / 12;
      background: #fff;
      border-radius: var(--card-radius);
      display: none;
      position: relative;
      /* NO overflow:hidden — lets donut hover-expand without clipping */
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
    }
    /* White background layer (since card has no overflow:hidden) */
    .card-bg {
      position: absolute;
      inset: 0;
      background: #fff;
      border-radius: var(--card-radius);
      z-index: 0;
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 50% 50%;
    }

    /* ── HEADER (spans full width) ── */
    .card-header {
      grid-column: 1 / -1;
      grid-row: 1;
      padding: 20px 28px 10px 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .card-target {
      font-family: var(--font-target);
      font-size: var(--fs-target);
      font-weight: var(--fw-target);
      letter-spacing: var(--ls-target);
      color: #0a0a0a;
      line-height: 1;
      text-align: center;
      width: 100%;
    }
    .stat-line {
      font-family: var(--font-stat);
      font-size: var(--fs-stat);
      font-weight: var(--fw-stat);
      letter-spacing: var(--ls-stat);
      color: #444;
      margin-top: 6px;
      text-align: center;
    }
    .stat-sep { color: #bbb; margin: 0 10px; }

    /* PASS / FAIL */
    .verdict-badge {
      position: absolute;
      top: 20px;
      right: 28px;
      padding: 7px 18px;
      border-radius: 0;
      border: none;
      font-family: var(--font-verdict);
      font-size: var(--fs-verdict);
      font-weight: var(--fw-verdict);
      letter-spacing: var(--ls-verdict);
      text-transform: uppercase;
    }
    .verdict-badge.pass { background: var(--pass-bg); color: var(--pass-text); }
    .verdict-badge.fail { background: var(--fail-bg); color: var(--fail-text); }

    /* ── LEFT: Donut column ── */
    .chart-col {
      grid-column: 1;
      grid-row: 2;
      display: flex;
      align-items: center;      /* vertical centre */
      justify-content: center;
      /* no overflow clipping here */
    }
    /*
      The wrapper must be large enough that hoverOffset expansion
      stays inside the canvas. We achieve this by giving Chart.js
      layout.padding = HOVER_OFFSET px (see JS CFG).
      That reserves internal canvas space so slices expand inward,
      not beyond the canvas edge.
    */
    #donutWrap {
      /* Fill ~90% of the column, square */
      width: min(380px, 90%);
      aspect-ratio: 1;
      position: relative;
      /* No extra CSS padding — Chart.js layout.padding handles hover room */
    }
    #donutWrap canvas {
      width:  100% !important;
      height: 100% !important;
      display: block;
    }

    /* ── RIGHT: Info panel ── */
    .info-col {
      grid-column: 2;
      grid-row: 2;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 6px 24px 20px 4px;
      gap: 10px;
      min-width: 0;
    }

    /* ── SHARED TABLE WRAPPER ── */
    .data-box {
      border: var(--table-border);
      border-radius: 2px;
      overflow: hidden;
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    /* Column headers */
    .data-table thead th {
      background: var(--header-bg);
      border-bottom: var(--table-border);
      font-family: var(--font-table-header);
      font-size: var(--fs-table-header);
      font-weight: var(--fw-table-header);
      letter-spacing: var(--ls-table-header);
      text-transform: uppercase;
      color: #6b7280;
      padding: var(--cell-pad-v) var(--cell-pad-h);
      text-align: center;
      white-space: nowrap;
    }
    /* Sources first column stays left-aligned */
    .data-table.sources-table thead th:first-child { text-align: left; }

    /* Body cells */
    .data-table tbody td {
      padding: var(--cell-pad-v) var(--cell-pad-h);
      border-bottom: var(--row-sep);
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .data-table tbody tr:last-child td { border-bottom: none; }

    /* ── Swatch ── */
    .swatch {
      width:         var(--swatch-w);
      height:        var(--swatch-h);
      border-radius: var(--swatch-radius);
      border:        var(--swatch-border);
      display:       inline-block;
      vertical-align: middle;
      margin-right:  8px;
      flex-shrink:   0;
    }

    /* ── Sources table columns ── */
    .col-source { width: 46%; text-align: left; }
    .col-coeff  { width: 33%; text-align: center; }
    .col-z      { width: 21%; text-align: center; }

    .pop-name {
      font-family: var(--font-pop-name);
      font-size:   var(--fs-pop-name);
      font-weight: var(--fw-pop-name);
      color: #111;
      vertical-align: middle;
    }
    .coeff-val {
      font-family: var(--font-coeff);
      font-size:   var(--fs-coeff);
      font-weight: var(--fw-coeff);
      color: #374151;
    }
    .z-cell {
      font-family: var(--font-z);
      font-size:   var(--fs-z);
      font-weight: var(--fw-z);
    }
    /* Z label + number always vertically aligned */
    .z-inner {
      display: inline-grid;
      grid-template-columns: 1.8em 4ch;
      /* "Z:" always in column 1, number always in column 2 */
      align-items: center;
    }
    .z-label { text-align: right; }
    .z-num   { text-align: right; }

    .z-good { color: var(--z-good-color); }
    .z-mid  { color: var(--z-mid-color);  }
    .z-bad  { color: var(--z-bad-color);  }

    /* ── Outgroups table (2 rows: header + single text cell) ── */
    .outgroups-table thead th { text-align: center !important; }
    .outgroups-td {
      font-family: var(--font-outgroup);
      font-size:   var(--fs-outgroup);
      font-weight: var(--fw-outgroup);
      color: #6b7280;
      white-space: normal;
      word-break: break-word;
      line-height: 1.6;
      text-align: left;
    }

    /* Watermark */
    .watermark {
      position: absolute;
      bottom: 8px;
      right: 12px;
      font-family: var(--font-watermark);
      font-size: 9px;
      font-weight: 500;
      color: #c0cad6;
      letter-spacing: 0.05em;
      z-index: 2;
    }

  </style>
</head>
<body>

  <div class="app-header">
    <h1 class="app-title">qpAdm Visualizer</h1>
    <span class="app-subtitle">Admixture Chart Generator</span>
  </div>

  <div class="input-panel">
    <textarea id="qpadmText" placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG: paste the full qpAdm output (left pops / right pops / best coefficients / std. errors / f4rank)
SUMMARY:  Target: X | Weights: PopA - 43.8% SE: 3.78% Z: 11.57 | P value: 0.15 | chisq: 8.04 | Rights: …"></textarea>

    <div class="controls-row">
      <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
      <select id="paletteSelect">
        <option value="0">Palette — Default</option>
        <option value="1">Palette — Set1</option>
        <option value="2">Palette — Dark2</option>
        <option value="3">Palette — Pastel</option>
        <option value="4">Palette — Tableau</option>
        <option value="5">Palette — Paired</option>
        <option value="6">Palette — Soft</option>
        <option value="7">Palette — Vibrant</option>
        <option value="8">Palette — Classic</option>
        <option value="9">Palette — Mixed</option>
      </select>
      <span id="formatBadge"></span>
      <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ Download PNG</button>
    </div>

    <div class="social-row">
      <div class="social-field">
        <label>Telegram</label>
        <input type="text" id="telegramInput" placeholder="@username">
      </div>
      <div class="social-field">
        <label>X / Twitter</label>
        <input type="text" id="xInput" placeholder="@username">
      </div>
      <div class="social-field">
        <label>Discord</label>
        <input type="text" id="discordInput" placeholder="username">
      </div>
    </div>
  </div>

  <!-- ══ 16:12 CARD ══ -->
  <div id="card">
    <div class="card-bg"></div>
    <div class="card-inner">

      <div class="card-header">
        <div class="card-target" id="cardTarget"></div>
        <div class="stat-line" id="statLine"></div>
        <div class="verdict-badge" id="verdictBadge"></div>
      </div>

      <!-- Donut -->
      <div class="chart-col">
        <div id="donutWrap">
          <canvas id="donutChart"></canvas>
        </div>
      </div>

      <!-- Info panel -->
      <div class="info-col">

        <!-- Sources table -->
        <div class="data-box">
          <table class="data-table sources-table">
            <thead>
              <tr>
                <th class="col-source">Sources</th>
                <th class="col-coeff">Coeff ± SE</th>
                <th class="col-z">Z-Score</th>
              </tr>
            </thead>
            <tbody id="sourcesBody"></tbody>
          </table>
        </div>

        <!-- Outgroups: header row + single data row with comma-separated string -->
        <div class="data-box" id="outgroupsBox" style="display:none;">
          <table class="data-table outgroups-table">
            <thead>
              <tr><th>Right (Outgroups)</th></tr>
            </thead>
            <tbody>
              <tr><td class="outgroups-td" id="outgroupsTd"></td></tr>
            </tbody>
          </table>
        </div>

      </div>
    </div><!-- .card-inner -->
    <div class="watermark" id="watermark"></div>
  </div><!-- #card -->

  <script>
    /* ══════════════════════════════════════════════════════════════
       JS CONFIG — mirrors CSS variables for Chart.js settings
       ══════════════════════════════════════════════════════════════ */
    const CFG = {
      donutCutout:     '52%',  /* hole size: 0% = solid, 90% = thin ring */
      donutBorderW:    2,      /* px – slice border width                 */
      donutBorderC:    '#000000',
      donutHoverOff:   14,     /* px – slice expansion on hover           */
      /* Chart.js layout.padding = donutHoverOff ensures expanding slices
         stay inside the canvas without any CSS padding on the wrapper    */
      zGoodMin:        3,
      zMidMin:         2,
    };

    let chartObj = null;

    const colorPalettes = [
      ["#4477aa","#ee6677","#228833","#ccbb44","#66ccee","#aa3377","#bbbbbb","#44bb99","#eedd88","#77aadd"],
      ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#a65628","#f781bf","#999999","#66c2a5","#fc8d62"],
      ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666","#1f78b4","#b2df8a"],
      ["#8dd3c7","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5"],
      ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],
      ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a"],
      ["#a8dadc","#457b9d","#e63946","#f4a261","#2a9d8f","#e9c46a","#264653","#b5838d","#6d6875","#c77dff"],
      ["#ff595e","#ffca3a","#6a4c93","#1982c4","#8ac926","#f86624","#ea3546","#662e9b","#43bccd","#f9c80e"],
      ["#264653","#2a9d8f","#e9c46a","#f4a261","#e76f51","#a8dadc","#457b9d","#1d3557","#e63946","#52b788"],
      ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3","#a6761d","#1b9e77"]
    ];

    function isRawFormat(t) {
      return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t);
    }

    function parseRaw(text) {
      const lines = text.split('\n');

      /* left pops */
      const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
      if (li < 0) throw new Error('"left pops:" not found');
      const leftPops = [];
      for (let i = li + 1; i < lines.length; i++) {
        const l = lines[i].trim();
        if (!l || /^right pops/i.test(l)) break;
        const m = l.match(/^(\S+)\s+\d+/);
        if (m) leftPops.push(m[1]);
      }
      if (leftPops.length < 2) throw new Error('Need target + ≥1 source in left pops');
      const target  = leftPops[0];
      const sources = leftPops.slice(1);

      /* right pops */
      const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
      const rightPops = [];
      if (ri >= 0) {
        for (let i = ri + 1; i < lines.length; i++) {
          const l = lines[i].trim();
          if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
          const m = l.match(/^(\S+)\s+\d+/);
          if (m) rightPops.push(m[1]);
        }
      }

      /* p-value + chisq */
      let pValue = NaN, chisq = NaN;
      const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
      if (ci >= 0) {
        for (let i = ci + 1; i < Math.min(ci + 6, lines.length); i++) {
          const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
          if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
        }
      }
      if (isNaN(pValue)) {
        for (const l of lines) {
          const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
          if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
        }
      }
      if (isNaN(pValue)) throw new Error('Could not parse p-value from f4rank line');

      /* coefficients */
      const cl = lines.find(l => /best coefficients:/.test(l));
      if (!cl) throw new Error('"best coefficients:" not found');
      const coeffs = cl.replace('best coefficients:', '').trim()
                       .split(/\s+/).map(Number).filter(v => !isNaN(v));
      if (coeffs.length !== sources.length)
        throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);

      /* SEs */
      const sl = lines.find(l => /std\.\s*errors:/.test(l));
      if (!sl) throw new Error('"std. errors:" not found');
      const ses = sl.replace(/std\.\s*errors:/, '').trim()
                    .split(/\s+/).map(Number).filter(v => !isNaN(v));
      if (ses.length !== sources.length)
        throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);

      const total   = coeffs.reduce((a, b) => a + b, 0);
      const weights = coeffs.map(c => (c / total) * 100);
      const sesPct  = ses.map(s => s * 100);
      const zScores = coeffs.map((c, i) => ses[i] > 0 ? c / ses[i] : 0);

      /* outgroups as comma-separated string */
      const outgroups = rightPops.join(', ');
      return { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups };
    }

    function parseSummary(text) {
      const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
      const tl = lines.find(l => l.startsWith('Target:'));
      if (!tl) throw new Error('Target line not found');
      const target = tl.replace('Target:', '').trim();

      const ws = lines.findIndex(l => l.startsWith('Weights:'));
      if (ws < 0) throw new Error('Weights section not found');

      const pvl = lines.find(l => l.startsWith('P value:'));
      const chl = lines.find(l => l.startsWith('chisq:'));
      if (!pvl) throw new Error('P value not found');
      if (!chl) throw new Error('chisq not found');

      const pValue = parseFloat(pvl.replace('P value:', '').trim());
      const chisq  = parseFloat(chl.replace('chisq:', '').trim());

      const rgl = lines.find(l => l.startsWith('Rights:'));
      const outgroups = rgl ? rgl.replace('Rights:', '').trim() : '';

      const sources = [], weights = [], sesPct = [], zScores = [];
      for (let i = ws + 1; i < lines.length; i++) {
        const l = lines[i];
        if (/^(P value:|chisq:|Rights:)/.test(l)) break;
        const m = l.match(/^(.+?)\s*-\s*([\d.]+)%\s*SE:\s*([\d.]+)%\s*Z:\s*([-\d.]+)/);
        if (m) {
          sources.push(m[1].trim());
          weights.push(parseFloat(m[2]));
          sesPct.push(parseFloat(m[3]));
          zScores.push(parseFloat(m[4]));
        }
      }
      if (!sources.length) throw new Error('No populations found in Weights block');
      const total = weights.reduce((a, b) => a + b, 0);
      return { target, sources, weights: weights.map(w => (w / total) * 100),
               sesPct, zScores, pValue, chisq, outgroups };
    }

    function zClass(z) {
      if (z >= CFG.zGoodMin) return 'z-good';
      if (z >= CFG.zMidMin)  return 'z-mid';
      return 'z-bad';
    }

    /* ══ MAIN RENDER ══ */
    function parseAndDraw() {
      const text = document.getElementById('qpadmText').value.trim();
      document.getElementById('card').style.display        = 'none';
      document.getElementById('downloadBtn').style.display = 'none';

      try {
        let parsed, fmtTxt, fmtCls;
        if (isRawFormat(text)) {
          parsed  = parseRaw(text);     fmtTxt = '⚙ Raw log'; fmtCls = 'raw';
        } else {
          parsed  = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = '';
        }
        const badge = document.getElementById('formatBadge');
        badge.textContent = fmtTxt; badge.className = fmtCls;
        badge.style.display = 'inline-block';

        const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;

        /* Verdict */
        const pass = pValue >= 0.05;
        const vb   = document.getElementById('verdictBadge');
        vb.textContent = pass ? 'PASS' : 'FAIL';
        vb.className   = 'verdict-badge ' + (pass ? 'pass' : 'fail');

        /* Target */
        document.getElementById('cardTarget').textContent = target;

        /* Stat line */
        const pd = pValue < 0.0001
          ? pValue.toExponential(4)
          : parseFloat(pValue.toPrecision(7)).toString();
        document.getElementById('statLine').innerHTML =
          `χ² = ${chisq.toFixed(2)}<span class="stat-sep"> / </span>p = ${pd}`;

        /* Colors */
        const pidx   = parseInt(document.getElementById('paletteSelect').value);
        const pal    = colorPalettes[pidx];
        const colors = sources.map((_, i) =>
          i < pal.length ? pal[i] : `hsl(${Math.round(360*i/sources.length)},62%,52%)`
        );

        /* ── Donut chart ──
           KEY FIX: layout.padding = CFG.donutHoverOff
           Chart.js reserves this many px inside the canvas before drawing,
           so when a slice expands on hover it grows into that reserved space
           rather than beyond the canvas edge → no clipping at any boundary.
           hoverBackgroundColor = same colors → no colour shift on hover.      */
        const ctx = document.getElementById('donutChart').getContext('2d');
        if (chartObj) chartObj.destroy();
        chartObj = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: sources,
            datasets: [{
              data:                 weights,
              backgroundColor:      colors,
              hoverBackgroundColor: colors,        /* ← no color change on hover */
              borderColor:          CFG.donutBorderC,
              hoverBorderColor:     CFG.donutBorderC,
              borderWidth:          CFG.donutBorderW,
              hoverBorderWidth:     CFG.donutBorderW,
              hoverOffset:          CFG.donutHoverOff
            }]
          },
          options: {
            responsive:  true,
            cutout:      CFG.donutCutout,
            layout: {
              padding:   CFG.donutHoverOff   /* ← reserve hover expansion room */
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` }
              }
            },
            animation: { animateRotate: true, duration: 550 }
          }
        });

        /* Sources rows */
        let srcRows = '';
        sources.forEach((pop, i) => {
          const z   = zScores[i];
          const zCl = zClass(z);
          srcRows += `<tr>
            <td class="col-source">
              <span class="swatch" style="background:${colors[i]}"></span>
              <span class="pop-name">${pop}</span>
            </td>
            <td class="col-coeff coeff-val">${weights[i].toFixed(1)}% ± ${sesPct[i].toFixed(2)}%</td>
            <td class="col-z z-cell ${zCl}">
              <span class="z-inner">
                <span class="z-label">Z:</span>
                <span class="z-num">${z.toFixed(2)}</span>
              </span>
            </td>
          </tr>`;
        });
        document.getElementById('sourcesBody').innerHTML = srcRows;

        /* Outgroups — single comma-separated cell */
        const ogBox = document.getElementById('outgroupsBox');
        const ogTd  = document.getElementById('outgroupsTd');
        if (outgroups) {
          ogTd.textContent    = outgroups;
          ogBox.style.display = 'block';
        } else {
          ogBox.style.display = 'none';
        }

        /* Watermark */
        const tg = document.getElementById('telegramInput').value.trim();
        const xw = document.getElementById('xInput').value.trim();
        const dc = document.getElementById('discordInput').value.trim();
        const parts = [];
        if (tg) parts.push(`TG: ${tg}`);
        if (xw) parts.push(`X: ${xw}`);
        if (dc) parts.push(`DC: ${dc}`);
        document.getElementById('watermark').textContent = parts.join('  ·  ');

        document.getElementById('card').style.display        = 'block';
        document.getElementById('downloadBtn').style.display = 'inline-block';

      } catch (e) {
        alert('Parse error:\n\n' + e.message);
        console.error(e);
      }
    }

    document.getElementById('paletteSelect').addEventListener('change', () => {
      if (chartObj) parseAndDraw();
    });

    function downloadImage() {
      const card = document.getElementById('card');
      /* Temporarily clip for a clean screenshot, then restore */
      card.style.overflow = 'hidden';
      html2canvas(card, { scale: 3, backgroundColor: '#ffffff', useCORS: true })
        .then(canvas => {
          card.style.overflow = '';
          const a = document.createElement('a');
          a.download = 'qpAdm_chart.png';
          a.href = canvas.toDataURL('image/png');
          a.click();
        });
    }
  </script>
</body>
</html>