<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>qpAdm Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700;900&family=IBM+Plex+Mono:wght@400;500;600&family=DM+Sans:wght@400;500;600;700&family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>

    /* ══════════════════════════════════════════════════════════════
       ▌ DESIGN TOKENS — edit these to restyle everything
       ══════════════════════════════════════════════════════════════ */
    :root {
      /* --- Fonts --- */
      --font-serif:      'Playfair Display', Georgia, serif;   /* card headings, pop names */
      --font-sans:       'DM Sans', Arial, sans-serif;          /* UI chrome, outgroup text */
      --font-mono:       'IBM Plex Mono', 'Courier New', monospace; /* stats line, numbers */

      /* --- Font weights --- */
      --fw-target:       900;     /* target population heading */
      --fw-stat:         500;     /* chi2 / p-value line */
      --fw-table-header: 600;     /* table column headers */
      --fw-pop-name:     500;     /* source population names */
      --fw-coeff:        400;     /* coefficient ± SE values */
      --fw-z:            600;     /* Z-score values */
      --fw-verdict:      700;     /* PASS / FAIL */
      --fw-outgroup:     400;     /* outgroup population names */

      /* --- Font sizes (inside card, relative to card width via clamp) --- */
      --fs-target:       clamp(22px, 3.8vw, 44px);
      --fs-stat:         clamp(11px, 1.45vw, 16px);
      --fs-table-header: clamp(8px,  0.85vw, 10.5px);
      --fs-pop-name:     clamp(10px, 1.1vw,  13px);
      --fs-coeff:        clamp(9px,  1.0vw,  12px);
      --fs-z:            clamp(9px,  1.0vw,  12px);
      --fs-verdict:      clamp(11px, 1.2vw,  14px);
      --fs-outgroup:     clamp(9px,  0.95vw, 11.5px);

      /* --- Text alignment --- */
      --align-target:    center;  /* target heading */
      --align-stat:      center;  /* stats line */

      /* --- Verdict badge colours --- */
      --pass-bg:         #dcfce7;  /* very light green fill */
      --pass-text:       #14532d;  /* dark green text */
      --fail-bg:         #fee2e2;  /* very light red fill */
      --fail-text:       #7f1d1d;  /* dark red text */

      /* --- Z-score tier thresholds & colours --- */
      --z-good-min:      3;        /* Z ≥ this → green */
      --z-mid-min:       2;        /* Z ≥ this → yellow (amber) */
                                   /* Z <  z-mid-min → red */
      --z-good-color:    #15803d;
      --z-mid-color:     #b45309;  /* amber/yellow */
      --z-bad-color:     #dc2626;

      /* --- Swatch (legend square) --- */
      --swatch-size:     14px;     /* width & height of colour square */
      --swatch-radius:   2px;      /* corner rounding (0 = sharp) */
      --swatch-border:   1.5px solid #000; /* black border like donut */

      /* --- Donut chart --- */
      --donut-cutout:    55%;      /* hole size: 0% = solid pie, 90% = thin ring */
      --donut-border-w:  2;        /* slice border width in px (number, not string) */
      --donut-border-c:  '#000000';/* slice border colour */
      --donut-hover-off: 10;       /* px expansion on hover */

      /* --- Card / table --- */
      --card-radius:     4px;
      --table-radius:    2px;
      --table-border:    1.5px solid #d1d5db;
      --table-row-sep:   1px solid #e5e7eb;
      --cell-pad:        7px 14px;
    }

    /* ══════════════════════════════════════════════════════════════
       ▌ RESET & BASE
       ══════════════════════════════════════════════════════════════ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background: #111;
      font-family: var(--font-sans);
      color: #e8e8e8;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 28px 20px 48px;
      gap: 20px;
    }

    /* ══════════════════════════════════════════════════════════════
       ▌ APP CHROME (outside the card)
       ══════════════════════════════════════════════════════════════ */
    .app-header {
      width: 100%;
      max-width: 1000px;
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    .app-title {
      font-family: var(--font-serif);
      font-size: 1.8rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.01em;
    }
    .app-subtitle {
      font-size: 0.7rem;
      font-weight: 600;
      color: #444;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    .input-panel {
      width: 100%;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    textarea {
      width: 100%;
      height: 150px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #c8c8c8;
      font-family: var(--font-mono);
      font-size: 11px;
      line-height: 1.65;
      padding: 12px 14px;
      resize: vertical;
      outline: none;
    }
    textarea:focus { border-color: #444; }
    textarea::placeholder { color: #333; }

    .controls-row, .social-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .social-field {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .social-field label {
      font-size: 10px;
      font-weight: 700;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      white-space: nowrap;
    }
    .social-field input {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #bbb;
      font-family: var(--font-sans);
      font-size: 12px;
      padding: 6px 9px;
      width: 120px;
      outline: none;
    }
    .social-field input:focus { border-color: #444; }

    .btn {
      padding: 8px 18px;
      border: none;
      border-radius: 3px;
      font-family: var(--font-sans);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-dl { background: #2563eb; color: #fff; display: none; }
    .btn-dl:hover { background: #1d4ed8; }

    select {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #bbb;
      font-family: var(--font-sans);
      font-size: 12px;
      padding: 8px 10px;
      cursor: pointer;
      outline: none;
    }
    #formatBadge {
      display: none;
      font-size: 10px;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 2px;
      background: #0d2b18;
      color: #4ade80;
      letter-spacing: 0.07em;
      text-transform: uppercase;
    }
    #formatBadge.raw { background: #2b1800; color: #fb923c; }

    /* ══════════════════════════════════════════════════════════════
       ▌ 16:12 OUTPUT CARD
       ══════════════════════════════════════════════════════════════ */
    #card {
      width: 100%;
      max-width: 1000px;
      aspect-ratio: 16 / 12;   /* ← 16:12 ratio */
      background: #ffffff;
      border-radius: var(--card-radius);
      display: none;
      position: relative;
      /* NO overflow:hidden — allows donut hover to expand freely */
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
    }

    /* Inner safe area clips only the card content, not the donut canvas */
    .card-bg {
      position: absolute;
      inset: 0;
      background: #fff;
      border-radius: var(--card-radius);
      z-index: 0;
    }

    .card-inner {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: grid;
      /* Header: full width top row
         Bottom: left = chart, right = table */
      grid-template-rows: auto 1fr;
      grid-template-columns: 50% 50%;
    }

    /* ── HEADER ── */
    .card-header {
      grid-column: 1 / -1;
      grid-row: 1;
      padding: 22px 30px 14px 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .card-target {
      font-family: var(--font-serif);
      font-size: var(--fs-target);
      font-weight: var(--fw-target);
      color: #0a0a0a;
      letter-spacing: -0.02em;
      line-height: 1;
      text-align: var(--align-target);
      width: 100%;
    }
    /* Stats: SANS-SERIF mono only */
    .stat-line {
      font-family: var(--font-mono);
      font-size: var(--fs-stat);
      font-weight: var(--fw-stat);
      color: #333;
      margin-top: 7px;
      text-align: var(--align-stat);
      letter-spacing: 0.02em;
    }
    .stat-sep { color: #bbb; margin: 0 10px; }

    /* PASS / FAIL */
    .verdict-badge {
      position: absolute;
      top: 20px;
      right: 28px;
      padding: 7px 18px;
      border-radius: 0;
      border: none;
      font-family: var(--font-serif);
      font-size: var(--fs-verdict);
      font-weight: var(--fw-verdict);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .verdict-badge.pass { background: var(--pass-bg); color: var(--pass-text); }
    .verdict-badge.fail { background: var(--fail-bg); color: var(--fail-text); }

    /* ── LEFT: Donut ── */
    .chart-col {
      grid-column: 1;
      grid-row: 2;
      display: flex;
      align-items: center;       /* vertical center */
      justify-content: center;
      padding: 10px 10px 24px 20px;
    }
    /* Wrapper gives breathing room so hoverOffset doesn't clip */
    #donutWrap {
      width: min(340px, 92%);
      height: min(340px, 92%);
      padding: 14px;             /* room for hover expansion */
      position: relative;
    }
    #donutWrap canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    /* ── RIGHT: Info panel ── */
    .info-col {
      grid-column: 2;
      grid-row: 2;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 6px 26px 26px 6px;
      gap: 10px;
      min-width: 0;
    }

    /* ── SHARED TABLE STYLE ── */
    .data-box {
      border: var(--table-border);
      border-radius: var(--table-radius);
      overflow: hidden;
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .data-table thead tr {
      background: #f3f4f6;
      border-bottom: var(--table-border);
    }
    .data-table thead th {
      font-family: var(--font-mono);
      font-size: var(--fs-table-header);
      font-weight: var(--fw-table-header);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #6b7280;
      padding: var(--cell-pad);
      text-align: center;
    }
    /* Left-align only the Sources/Name column header */
    .data-table thead th:first-child { text-align: left; }

    .data-table tbody td {
      padding: var(--cell-pad);
      border-bottom: var(--table-row-sep);
      color: #111;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .data-table tbody tr:last-child td { border-bottom: none; }

    /* swatch square */
    .swatch {
      width: var(--swatch-size);
      height: var(--swatch-size);
      border-radius: var(--swatch-radius);
      border: var(--swatch-border);
      display: inline-block;
      vertical-align: middle;
      margin-right: 7px;
      flex-shrink: 0;
    }

    .pop-name {
      font-family: var(--font-serif);
      font-size: var(--fs-pop-name);
      font-weight: var(--fw-pop-name);
      vertical-align: middle;
    }

    /* coeff ± SE column */
    .col-coeff {
      font-family: var(--font-mono);
      font-size: var(--fs-coeff);
      font-weight: var(--fw-coeff);
      color: #374151;
      text-align: center;
    }

    /* Z-score column — split into "Z:" label + number for rigid alignment */
    .col-z {
      font-family: var(--font-mono);
      font-size: var(--fs-z);
      font-weight: var(--fw-z);
      text-align: center;
    }
    .z-inner {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      /* fixed-width label so numbers always line up */
    }
    .z-label {
      /* "Z:" always same width */
      display: inline-block;
      width: 1.5em;
      text-align: right;
      flex-shrink: 0;
    }
    .z-num {
      display: inline-block;
      min-width: 4ch;
      text-align: right;
    }
    .z-good   { color: var(--z-good-color); }
    .z-mid    { color: var(--z-mid-color);  }
    .z-bad    { color: var(--z-bad-color);  }

    /* Outgroups table — lighter text */
    .outgroups-table .pop-name {
      font-family: var(--font-sans);
      font-size: var(--fs-outgroup);
      font-weight: var(--fw-outgroup);
      color: #6b7280;
      white-space: normal;
      line-height: 1.5;
    }
    .outgroups-table tbody td { color: #6b7280; white-space: normal; }

    /* Watermark */
    .watermark {
      position: absolute;
      bottom: 8px;
      right: 12px;
      font-family: var(--font-mono);
      font-size: 9px;
      font-weight: 500;
      color: #c0cad6;
      letter-spacing: 0.05em;
      z-index: 2;
    }

  </style>
</head>
<body>

  <div class="app-header">
    <h1 class="app-title">qpAdm Visualizer</h1>
    <span class="app-subtitle">Admixture Chart Generator</span>
  </div>

  <div class="input-panel">
    <textarea id="qpadmText" placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG: must contain left pops / right pops / best coefficients / std. errors / f4rank lines.
SUMMARY:  Target: X | Weights: PopA - 43.8% SE: 3.78% Z: 11.57 | P value: 0.15 | chisq: 8.04 | Rights: …"></textarea>

    <div class="controls-row">
      <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
      <select id="paletteSelect">
        <option value="0">Palette — Default</option>
        <option value="1">Palette — Set1</option>
        <option value="2">Palette — Dark2</option>
        <option value="3">Palette — Pastel</option>
        <option value="4">Palette — Tableau</option>
        <option value="5">Palette — Paired</option>
        <option value="6">Palette — Soft</option>
        <option value="7">Palette — Vibrant</option>
        <option value="8">Palette — Classic</option>
        <option value="9">Palette — Mixed</option>
      </select>
      <span id="formatBadge"></span>
      <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ Download PNG</button>
    </div>

    <div class="social-row">
      <div class="social-field">
        <label>Telegram</label>
        <input type="text" id="telegramInput" placeholder="@username">
      </div>
      <div class="social-field">
        <label>X / Twitter</label>
        <input type="text" id="xInput" placeholder="@username">
      </div>
      <div class="social-field">
        <label>Discord</label>
        <input type="text" id="discordInput" placeholder="username">
      </div>
    </div>
  </div>

  <!-- ══════ 16:12 CARD ══════ -->
  <div id="card">
    <div class="card-bg"></div>
    <div class="card-inner">

      <div class="card-header">
        <div class="card-target" id="cardTarget"></div>
        <div class="stat-line"   id="statLine"></div>
        <div class="verdict-badge" id="verdictBadge"></div>
      </div>

      <div class="chart-col">
        <div id="donutWrap">
          <canvas id="donutChart"></canvas>
        </div>
      </div>

      <div class="info-col">

        <!-- Sources table -->
        <div class="data-box">
          <table class="data-table" id="sourcesTable">
            <thead>
              <tr>
                <th style="width:48%">Sources</th>
                <th style="width:32%">Coeff ± SE</th>
                <th style="width:20%">Z-Score</th>
              </tr>
            </thead>
            <tbody id="sourcesBody"></tbody>
          </table>
        </div>

        <!-- Outgroups table -->
        <div class="data-box" id="outgroupsBox" style="display:none;">
          <table class="data-table outgroups-table">
            <thead>
              <tr>
                <th style="text-align:center">Right (Outgroups)</th>
              </tr>
            </thead>
            <tbody id="outgroupsBody"></tbody>
          </table>
        </div>

      </div>
    </div>
    <div class="watermark" id="watermark"></div>
  </div>

  <script>
    /* ══════════════════════════════════════════════════════════════
       JS DESIGN TOKENS — mirrors the CSS variables for Chart.js
       ══════════════════════════════════════════════════════════════ */
    const CFG = {
      donutCutout:  '55%',   /* matches --donut-cutout */
      donutBorderW: 2,        /* matches --donut-border-w */
      donutBorderC: '#000000',/* matches --donut-border-c */
      donutHoverOff: 10,      /* matches --donut-hover-off */
      zGoodMin: 3,            /* matches --z-good-min */
      zMidMin:  2,            /* matches --z-mid-min */
    };

    let chartObj = null;

    const colorPalettes = [
      ["#4477aa","#ee6677","#228833","#ccbb44","#66ccee","#aa3377","#bbbbbb","#44bb99","#eedd88","#77aadd"],
      ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#a65628","#f781bf","#999999","#66c2a5","#fc8d62"],
      ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666","#1f78b4","#b2df8a"],
      ["#8dd3c7","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5"],
      ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],
      ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a"],
      ["#a8dadc","#457b9d","#e63946","#f4a261","#2a9d8f","#e9c46a","#264653","#b5838d","#6d6875","#c77dff"],
      ["#ff595e","#ffca3a","#6a4c93","#1982c4","#8ac926","#f86624","#ea3546","#662e9b","#43bccd","#f9c80e"],
      ["#264653","#2a9d8f","#e9c46a","#f4a261","#e76f51","#a8dadc","#457b9d","#1d3557","#e63946","#52b788"],
      ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3","#a6761d","#1b9e77"]
    ];

    /* ── Format detection ── */
    function isRawFormat(t) {
      return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t);
    }

    /* ── Raw qpAdm parser ── */
    function parseRaw(text) {
      const lines = text.split('\n');

      const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
      if (li < 0) throw new Error('"left pops:" not found');
      const leftPops = [];
      for (let i = li + 1; i < lines.length; i++) {
        const l = lines[i].trim();
        if (!l || /^right pops/i.test(l)) break;
        const m = l.match(/^(\S+)\s+\d+/);
        if (m) leftPops.push(m[1]);
      }
      if (leftPops.length < 2) throw new Error('Need target + ≥1 source in left pops');
      const target  = leftPops[0];
      const sources = leftPops.slice(1);

      const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
      const rightPops = [];
      if (ri >= 0) {
        for (let i = ri + 1; i < lines.length; i++) {
          const l = lines[i].trim();
          if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
          const m = l.match(/^(\S+)\s+\d+/);
          if (m) rightPops.push(m[1]);
        }
      }

      let pValue = NaN, chisq = NaN;
      const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
      if (ci >= 0) {
        for (let i = ci + 1; i < Math.min(ci + 6, lines.length); i++) {
          const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
          if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
        }
      }
      if (isNaN(pValue)) {
        for (const l of lines) {
          const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
          if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
        }
      }
      if (isNaN(pValue)) throw new Error('Could not parse p-value from f4rank line');

      const cl = lines.find(l => /best coefficients:/.test(l));
      if (!cl) throw new Error('"best coefficients:" line not found');
      const coeffs = cl.replace('best coefficients:', '').trim().split(/\s+/).map(Number).filter(v => !isNaN(v));
      if (coeffs.length !== sources.length)
        throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);

      const sl = lines.find(l => /std\.\s*errors:/.test(l));
      if (!sl) throw new Error('"std. errors:" line not found');
      const ses = sl.replace(/std\.\s*errors:/, '').trim().split(/\s+/).map(Number).filter(v => !isNaN(v));
      if (ses.length !== sources.length)
        throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);

      const total   = coeffs.reduce((a, b) => a + b, 0);
      const weights = coeffs.map(c => (c / total) * 100);
      const sesPct  = ses.map(s => s * 100);
      const zScores = coeffs.map((c, i) => ses[i] > 0 ? c / ses[i] : 0);
      return { target, sources, weights, sesPct, zScores, pValue, chisq,
               outgroups: rightPops };
    }

    /* ── Summary parser ── */
    function parseSummary(text) {
      const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
      const tl = lines.find(l => l.startsWith('Target:'));
      if (!tl) throw new Error('Target line not found');
      const target = tl.replace('Target:', '').trim();

      const ws = lines.findIndex(l => l.startsWith('Weights:'));
      if (ws < 0) throw new Error('Weights section not found');

      const pvl = lines.find(l => l.startsWith('P value:'));
      const chl = lines.find(l => l.startsWith('chisq:'));
      if (!pvl) throw new Error('P value not found');
      if (!chl) throw new Error('chisq not found');

      const pValue = parseFloat(pvl.replace('P value:', '').trim());
      const chisq  = parseFloat(chl.replace('chisq:', '').trim());
      const rgl    = lines.find(l => l.startsWith('Rights:'));
      const outgroups = rgl ? rgl.replace('Rights:', '').trim().split(/[,\s]+/).filter(Boolean) : [];

      const sources = [], weights = [], sesPct = [], zScores = [];
      for (let i = ws + 1; i < lines.length; i++) {
        const l = lines[i];
        if (/^(P value:|chisq:|Rights:)/.test(l)) break;
        const m = l.match(/^(.+?)\s*-\s*([\d.]+)%\s*SE:\s*([\d.]+)%\s*Z:\s*([-\d.]+)/);
        if (m) {
          sources.push(m[1].trim());
          weights.push(parseFloat(m[2]));
          sesPct.push(parseFloat(m[3]));
          zScores.push(parseFloat(m[4]));
        }
      }
      if (!sources.length) throw new Error('No populations found');
      const total = weights.reduce((a, b) => a + b, 0);
      return { target, sources, weights: weights.map(w => (w / total) * 100),
               sesPct, zScores, pValue, chisq, outgroups };
    }

    /* ── Z-score CSS class ── */
    function zClass(z) {
      if (z >= CFG.zGoodMin) return 'z-good';
      if (z >= CFG.zMidMin)  return 'z-mid';
      return 'z-bad';
    }

    /* ── MAIN RENDER ── */
    function parseAndDraw() {
      const text = document.getElementById('qpadmText').value.trim();
      document.getElementById('card').style.display        = 'none';
      document.getElementById('downloadBtn').style.display = 'none';

      try {
        let parsed, fmtTxt, fmtCls;
        if (isRawFormat(text)) {
          parsed = parseRaw(text);    fmtTxt = '⚙ Raw log'; fmtCls = 'raw';
        } else {
          parsed = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = '';
        }
        const badge = document.getElementById('formatBadge');
        badge.textContent = fmtTxt; badge.className = fmtCls;
        badge.style.display = 'inline-block';

        const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;

        /* Verdict */
        const pass = pValue >= 0.05;
        const vb   = document.getElementById('verdictBadge');
        vb.textContent = pass ? 'PASS' : 'FAIL';
        vb.className   = 'verdict-badge ' + (pass ? 'pass' : 'fail');

        /* Target heading */
        document.getElementById('cardTarget').textContent = target;

        /* Stats line — monospace only */
        const pd = pValue < 0.0001
          ? pValue.toExponential(4)
          : parseFloat(pValue.toPrecision(7)).toString();
        document.getElementById('statLine').innerHTML =
          `χ² = ${chisq.toFixed(2)}<span class="stat-sep">/</span>p = ${pd}`;

        /* Colors */
        const pidx   = parseInt(document.getElementById('paletteSelect').value);
        const pal    = colorPalettes[pidx];
        const colors = sources.map((_, i) =>
          i < pal.length ? pal[i] : `hsl(${Math.round(360*i/sources.length)},62%,52%)`
        );

        /* Donut chart
           Key fixes:
           - hoverBackgroundColor = same as backgroundColor → no color shift on hover
           - hoverOffset via CFG.donutHoverOff
           - canvas wrapper has padding so expanded slice isn't clipped
           - card has no overflow:hidden (the .card-bg div provides the background) */
        const ctx = document.getElementById('donutChart').getContext('2d');
        if (chartObj) chartObj.destroy();
        chartObj = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: sources,
            datasets: [{
              data:                  weights,
              backgroundColor:       colors,
              hoverBackgroundColor:  colors,   /* ← prevents color change on hover */
              borderColor:           CFG.donutBorderC,
              hoverBorderColor:      CFG.donutBorderC,
              borderWidth:           CFG.donutBorderW,
              hoverBorderWidth:      CFG.donutBorderW,
              hoverOffset:           CFG.donutHoverOff
            }]
          },
          options: {
            responsive: true,
            cutout: CFG.donutCutout,
            layout: { padding: 0 },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` }
              }
            },
            animation: { animateRotate: true, duration: 550 }
          }
        });

        /* Sources table body */
        let srcRows = '';
        sources.forEach((pop, i) => {
          const z   = zScores[i];
          const zCl = zClass(z);
          srcRows += `<tr>
            <td style="text-align:left">
              <span class="swatch" style="background:${colors[i]}"></span>
              <span class="pop-name">${pop}</span>
            </td>
            <td class="col-coeff">${weights[i].toFixed(1)}% ± ${sesPct[i].toFixed(2)}%</td>
            <td class="col-z ${zCl}">
              <span class="z-inner">
                <span class="z-label">Z:</span>
                <span class="z-num">${z.toFixed(2)}</span>
              </span>
            </td>
          </tr>`;
        });
        document.getElementById('sourcesBody').innerHTML = srcRows;

        /* Outgroups table */
        const ogBox  = document.getElementById('outgroupsBox');
        const ogBody = document.getElementById('outgroupsBody');
        if (outgroups && outgroups.length) {
          /* Each outgroup on its own row, or all in one row — one row per pop looks cleaner */
          ogBody.innerHTML = outgroups.map(og =>
            `<tr><td class="outgroups-table" style="text-align:center">
              <span class="pop-name" style="font-family:var(--font-sans);font-weight:400;color:#6b7280;font-size:var(--fs-outgroup)">${og}</span>
            </td></tr>`
          ).join('');
          ogBox.style.display = 'block';
        } else {
          ogBox.style.display = 'none';
        }

        /* Watermark */
        const tg = document.getElementById('telegramInput').value.trim();
        const xw = document.getElementById('xInput').value.trim();
        const dc = document.getElementById('discordInput').value.trim();
        const parts = [];
        if (tg) parts.push(`TG: ${tg}`);
        if (xw) parts.push(`X: ${xw}`);
        if (dc) parts.push(`DC: ${dc}`);
        document.getElementById('watermark').textContent = parts.join('  ·  ');

        document.getElementById('card').style.display        = 'block';
        document.getElementById('downloadBtn').style.display = 'inline-block';

      } catch (e) {
        alert('Parse error:\n\n' + e.message);
        console.error(e);
      }
    }

    document.getElementById('paletteSelect').addEventListener('change', () => {
      if (chartObj) parseAndDraw();
    });

    function downloadImage() {
      /* Temporarily clip overflow for clean screenshot */
      const card = document.getElementById('card');
      card.style.overflow = 'hidden';
      html2canvas(card, { scale: 3, backgroundColor: '#ffffff', useCORS: true })
        .then(canvas => {
          card.style.overflow = '';
          const a = document.createElement('a');
          a.download = 'qpAdm_chart.png';
          a.href = canvas.toDataURL('image/png');
          a.click();
        });
    }
  </script>
</body>
</html>