<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>qpAdm Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,400&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh; background: #111; font-family: 'Roboto', sans-serif;
      color: #e8e8e8; display: flex; flex-direction: column;
      align-items: center; padding: 28px 20px 48px; gap: 20px;
    }
    .app-header { width: 100%; max-width: 1000px; display: flex; align-items: baseline; gap: 12px; }
    .app-title  { font-size: 1.7rem; font-weight: 700; color: #fff; letter-spacing: -0.01em; }
    .app-subtitle { font-size: 0.7rem; font-weight: 500; color: #444; letter-spacing: 0.14em; text-transform: uppercase; }
    .input-panel { width: 100%; max-width: 1000px; display: flex; flex-direction: column; gap: 10px; }
    textarea { width: 100%; height: 150px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #c8c8c8; font-family: monospace; font-size: 11px; line-height: 1.65; padding: 12px 14px; resize: vertical; outline: none; }
    textarea:focus { border-color: #444; }
    textarea::placeholder { color: #333; }
    .controls-row, .social-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .social-field { display: flex; align-items: center; gap: 6px; }
    .social-field label { font-size: 10px; font-weight: 700; color: #444; text-transform: uppercase; letter-spacing: 0.1em; white-space: nowrap; }
    .social-field input { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 6px 9px; width: 120px; outline: none; }
    .social-field input:focus { border-color: #444; }
    .btn { padding: 8px 18px; border: none; border-radius: 3px; font-size: 13px; font-weight: 600; cursor: pointer; }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-dl { background: #2563eb; color: #fff; display: none; }
    .btn-dl:hover { background: #1d4ed8; }
    select { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 3px; color: #bbb; font-size: 12px; padding: 8px 10px; cursor: pointer; outline: none; }
    #formatBadge { display: none; font-size: 10px; font-weight: 700; padding: 4px 10px; border-radius: 2px; background: #0d2b18; color: #4ade80; letter-spacing: 0.07em; text-transform: uppercase; }
    #formatBadge.raw { background: #2b1800; color: #fb923c; }

    /* ═══ CARD ═══ */
    #card {
      width: 100%; max-width: 1000px; aspect-ratio: 16 / 10.5;
      background: #fff; border-radius: 4px; display: none;
      position: relative; overflow: visible;
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
    }
    .card-bg { position: absolute; inset: 0; background: #fff; border-radius: 4px; z-index: 0; pointer-events: none; }

    /* ═══ HEADER ═══ */
    .card-header { position: absolute; top: 0; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; z-index: 2; }
    #cardTarget { width: 100%; }
    .stat-sep { color: #bbb; margin: 0 8px; }

    /* ═══ PASS/FAIL — colours and geometry both from JS config ═══ */
    .verdict-badge { position: absolute; border: none; border-radius: 0; text-transform: uppercase; z-index: 3; }

    /* ═══ DONUT ═══ */
    #donutWrap { position: absolute; z-index: 10; }
    #donutWrap canvas { width: 100% !important; height: 100% !important; display: block; }

    /* ═══ INFO PANEL ═══ */
    .info-col { position: absolute; display: flex; flex-direction: column; justify-content: center; gap: 10px; min-width: 0; z-index: 2; }

    /* ═══ TABLES — structural skeleton only; colours/borders from TABLE_STYLE ═══ */
    .data-box   { overflow: hidden; }
    .data-table { width: 100%; border-collapse: collapse; table-layout: fixed; }

    /* ── Column width control (sources table) ── */
    .col-sw-col {
      width: 40px;          /* hard clamp for swatch */
    }

    .col-name-col {
      width: auto;          /* takes remaining space */
    }

    .col-data-col {
      width: 220px;         /* fixed numeric column */
    }

    /* Columns */
    .col-sw   { vertical-align: middle; text-align: left; }
    .col-name { vertical-align: middle; overflow: visible; white-space: normal; word-break: normal; overflow-wrap: normal; }
    .col-data { vertical-align: middle; }

    .swatch   { display: inline-block; vertical-align: middle; flex-shrink: 0; }
    .pop-name { vertical-align: middle; hyphens: none; line-height: 1.35; }

    /* Z-score colour tiers */
    .z-good { color: #16a34a; }
    .z-mid  { color: #ca8a04; }
    .z-bad  { color: #dc2626; }

    /* Outgroups */
    .outgroups-td { white-space: normal; word-break: break-word; overflow-wrap: break-word; }

    /* Watermark */
    .watermark { position: absolute; bottom: 8px; right: 12px; z-index: 5; }
  </style>
</head>
<body>

<div class="app-header">
  <h1 class="app-title">qpAdm Visualizer</h1>
  <span class="app-subtitle">Admixture Chart Generator</span>
</div>

<div class="input-panel">
  <textarea id="qpadmText" placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG: full qpAdm output (left pops / right pops / best coefficients / std. errors / f4rank)
SUMMARY:  Target: X | Weights: PopA - 43.8% SE: 3.78% Z: 11.57 | P value: 0.15 | chisq: 8.04 | Rights: …"></textarea>
  <div class="controls-row">
    <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
    <select id="paletteSelect">
      <option value="0">Palette — Default (≤6)</option>
      <option value="1">Palette — Tableau (≤6)</option>
      <option value="2">Palette — Dark2 (≤6)</option>
      <option value="3">Palette — Soft Modern</option>
      <option value="4">Palette — Earth</option>
      <option value="5">Palette — Greyscale</option>
    </select>
    <span id="formatBadge"></span>
    <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ Download PNG</button>
  </div>
  <div class="social-row">
    <div class="social-field"><label>Telegram</label><input type="text" id="telegramInput" placeholder="@username"></div>
    <div class="social-field"><label>X / Twitter</label><input type="text" id="xInput" placeholder="@username"></div>
    <div class="social-field"><label>Discord</label><input type="text" id="discordInput" placeholder="username"></div>
  </div>
</div>

<!-- CARD -->
<div id="card">
  <div class="card-bg"></div>
  <div class="card-header" id="cardHeader">
    <div id="cardTarget"></div>
    <div id="statLine"></div>
    <div class="verdict-badge" id="verdictBadge"></div>
  </div>
  <div id="donutWrap"><canvas id="donutChart"></canvas></div>
  <div class="info-col" id="infoCol">
    <div class="data-box" id="sourcesBox">
      <table class="data-table" id="sourcesTable">
        <colgroup>
          <col class="col-sw-col">
          <col class="col-name-col">
          <col class="col-data-col">
        </colgroup>
        <thead id="sourcesHead"></thead>
        <tbody id="sourcesBody"></tbody>
      </table>
    </div>
    <div class="data-box" id="outgroupsBox" style="display:none;">
      <table class="data-table outgroups-table" id="outgroupsTable">
        <thead><tr><th id="hdrOutgroups"></th></tr></thead>
        <tbody><tr><td class="outgroups-td" id="outgroupsTd"></td></tr></tbody>
      </table>
    </div>
  </div>
  <div class="watermark" id="watermark"></div>
</div>

<script>
/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  LAYOUT  —  positions as % of card width (X) or card height (Y)         ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const LAYOUT = {
  donutCenterX:   23,   /* % card W — donut centre horizontal */
  donutCenterY:   55,   /* % card H — donut centre vertical   */
  donutDiameter:  43,   /* % card W — donut diameter          */

  panelLeft:       48,  /* % card W — info panel left edge    */
  panelTop:        18,  /* % card H — info panel top edge     */
  panelRight:       2,  /* % card W — info panel right inset  */
  panelBottom:      3,  /* % card H — info panel bottom inset */
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  VERDICT BADGE — position, size, colours                                ║
   ║                                                                          ║
   ║  anchorX / anchorY  position of badge anchor as % of card W / H         ║
   ║  anchor             which corner sits at anchorX/Y:                     ║
   ║                     'top-right' 'top-left' 'top-center'                ║
   ║                     'bottom-right' 'bottom-left' 'bottom-center'       ║
   ║  minWidth / minHeight  minimum badge size in px  (0 = auto)            ║
   ║  paddingV / paddingH   inner padding px                                 ║
   ║  textAlign          text alignment inside badge                         ║
   ║                                                                          ║
   ║  COLOURS (replaces the old CSS .pass / .fail rules):                    ║
   ║  passBg / passText  background + text colour when PASS                  ║
   ║  failBg / failText  background + text colour when FAIL                  ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const VERDICT_POS = {
  anchorX:    98,
  anchorY:    3,
  anchor:     'top-right',
  minWidth:   0,
  minHeight:  0,
  paddingV:   8,
  paddingH:   8,
  textAlign:  'center',

  /* ── badge colours — edit freely ── */
  /* STRONG PASS */
  passBg:     '#f3fefd',
  passText:   '#3a9063',

  /* WEAK PASS (yellow, restrained, scientific) */
  weakBg:     '#fefce8',
  weakText:   '#ca8a04',

  /* FAIL */
  failBg:     '#f8eaea',
  failText:   '#dc2626',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  TABLE STYLE  —  borders, backgrounds for both tables                   ║
   ║                                                                          ║
   ║  boxBorderWidth      outer box border thickness  e.g. '1.5px'           ║
   ║  boxBorderColor      outer box border colour                             ║
   ║  boxBorderRadius     outer box corner radius                             ║
   ║                                                                          ║
   ║  headerBg            header row background colour                       ║
   ║  headerBorderWidth   line beneath header row                             ║
   ║  headerBorderColor   colour of that line                                 ║
   ║                                                                          ║
   ║  rowBorderWidth      separator between body rows                        ║
   ║  rowBorderColor      colour of row separators                           ║
   ║                                                                          ║
   ║  cellBg              default body cell background  ('transparent' = off)║
   ║  evenRowBg           override bg for even-indexed rows (0-based)        ║
   ║  oddRowBg            override bg for odd-indexed rows                   ║
   ║    set evenRowBg / oddRowBg to 'transparent' to disable zebra striping  ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const TABLE_STYLE = {
  boxBorderWidth:    '1.5px',
  boxBorderColor:    '#d1d5db',
  boxBorderRadius:   '2px',

  headerBg:          '#f3f4f6',
  headerBorderWidth: '1.5px',
  headerBorderColor: '#d1d5db',

  rowBorderWidth:    '1px',
  rowBorderColor:    '#e5e7eb',

  cellBg:            'transparent',  /* base cell bg */
  evenRowBg:         'transparent',  /* even rows — set a colour for zebra */
  oddRowBg:          'transparent',  /* odd rows  */
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  DONUT CONFIG                                                            ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const CFG = {
  donutCutout:      '65%',
  donutBorderW:     2,
  donutBorderC:     '#000000',
  donutHoverOff:    14,
  donutClockwise:   true,
  donutStartAngle:  0,
  zGoodMin:         3,
  zMidMin:          2,
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  SWATCH                                                                  ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const SWATCH = {
  width:   '29px',
  height:  '23px',
  radius:  '0px',
  border:  '1.8px solid #000',
};

/* ╔══════════════════════════════════════════════════════════════════════════╗
   ║  TYPOGRAPHY  —  every text element on the output card                   ║
   ║                                                                          ║
   ║  Keys in every section:                                                  ║
   ║    font / fontSize / fontWeight / fontStyle / color                     ║
   ║    letterSpacing / lineHeight / align                                   ║
   ╚══════════════════════════════════════════════════════════════════════════╝ */
const TYPOGRAPHY = {

  /* ── Population name heading ── */
  target: {
    font:          'Roboto, sans-serif',
    fontSize:      'clamp(40px, 4.5vw, 60px)',
    fontWeight:    900,
    fontStyle:     'normal',
    color:         '#0a0a0a',
    letterSpacing: '-0.02em',
    lineHeight:    '1.05',
    align:         'center',
  },

  /* ── χ² / p-value line ── */
  stat: {
    font:          'Cascadia Code, sans-serif',
    fontSize:      'clamp(18px, 2.0vw, 30px)',
    fontWeight:    400,
    fontStyle:     'normal',
    color:         '#555555',
    letterSpacing: '0.01em',
    lineHeight:    '1.3',
    align:         'center',
    marginTop:     '2px',
  },

  /* ── Header area padding ── */
  headerPadding: {
    top:    '10px',
    sides:  '24px',
    bottom: '0px',
  },

  /* ── PASS / FAIL text style (colours live in VERDICT_POS above) ── */
  verdict: {
    font: 'Inter, sans-serif',
    fontSize: 'clamp(10px, 1.9vw, 18px)',
    fontWeight: 800,
    fontStyle: 'normal',
    letterSpacing: '0.14em',
  },


  /* ── Sources table: merged header ── */
  sourcesHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Coeff \u00B1 SE  (Z-score)',
    textTransform: 'uppercase',
  },

  /* ── Source name cell ── */
  sourcesName: {
    font:          'Roboto, sans-serif',
    fontSize:      '17px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    lineHeight:    '1.35',
    align:         'left',
  },

  /* ── Coeff ± SE portion ── */
  sourcesCoeff: {
    font:          'Roboto, sans-serif',
    fontSize:      '17px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#111111',
    letterSpacing: '0',
    align:         'left',
  },

  /* ── Z-score portion ──
     zPrefix      text before the number  e.g. 'Z: '
     zSepPx       px gap between coeff block and opening paren  ← NEW
     zGap         gap between "Z:" and the number (kept for compatibility)  */
  sourcesZ: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    700,
    fontStyle:     'normal',
    letterSpacing: '0',
    zPrefix:       'Z:\u2009',   /* thin-space after colon */
    zSepPx:        8,            /* px gap between coeff value and (Z: …) bracket */
    zGap:          '3px',        /* kept — no longer used in rendering but preserved */
  },

  /* ── Colon separator (": ") between name and data columns ── */
  sourcesColon: {
    colonText:   ': ',
    colonFont:   'Roboto, sans-serif',
    colonColor:  '#111111',
  },

  /* ── Per-row overrides ──────────────────────────────────────────────────
     { index: N, <prefixed key>: value }
     name*   nameFont nameFontSize nameFontWeight nameFontStyle
             nameColor nameLetterSpacing nameLineHeight nameAlign
     coeff*  coeffFont coeffFontSize coeffFontWeight coeffFontStyle
             coeffColor coeffLetterSpacing coeffAlign
     z*      zFont zFontSize zFontWeight zFontStyle zLetterSpacing zGap      */
  sourcesRowOverrides: [
    // { index: 0, nameColor: '#e63946' },
  ],

  /* ── Outgroups header ── */
  outgroupsHeader: {
    font:          'Roboto, sans-serif',
    fontSize:      '12px',
    fontWeight:    600,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0.1em',
    lineHeight:    '1.4',
    align:         'center',
    text:          'Right (Outgroups)',
    textTransform: 'uppercase',
  },

  /* ── Outgroups data cell ── */
  outgroupsCell: {
    font:          'Roboto, sans-serif',
    fontSize:      '15px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#6b7280',
    letterSpacing: '0',
    lineHeight:    '1.6',
    align:         'left',
  },

  /* ── Watermark ── */
  watermark: {
    font:          'Roboto, sans-serif',
    fontSize:      '9px',
    fontWeight:    500,
    fontStyle:     'normal',
    color:         '#c0cad6',
    letterSpacing: '0.05em',
  },
};

/* ══ COLOR PALETTES (CAPPED AT 6 COMPONENTS) ══ */
const colorPalettes = [

  /* 0 — Default (scientific, colorblind-safe) */
  ['#4477aa','#228833','#ee6677','#ccbb44','#66ccee','#aa3377'],

  /* 1 — Tableau (clean analytics) */
  ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b'],

  /* 2 — Dark2 (strong separation) */
  ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#a6761d'],

  /* 3 — Soft modern */
  ['#457b9d','#2a9d8f','#e63946','#f4a261','#264653','#b5838d'],

  /* 4 — Earth / archaeogenetics */
  ['#5b8c5a','#4c6a92','#c97c5d','#b1a44c','#7a4a6e','#6b705c'],

  /* 5 — Greyscale (print & colorblind safe) */
  ['#111111','#2f2f2f','#555555','#7a7a7a','#a0a0a0','#cfcfcf'],
];


let chartObj = null;

/* ── Apply TYPOGRAPHY section to element ── */
function applyT(el, t) {
  if (!el || !t) return;
  if (t.font)          el.style.fontFamily    = t.font;
  if (t.fontSize)      el.style.fontSize      = t.fontSize;
  if (t.fontWeight)    el.style.fontWeight    = t.fontWeight;
  if (t.fontStyle)     el.style.fontStyle     = t.fontStyle;
  if (t.color)         el.style.color         = t.color;
  if (t.letterSpacing) el.style.letterSpacing = t.letterSpacing;
  if (t.lineHeight)    el.style.lineHeight    = t.lineHeight;
  if (t.align)         el.style.textAlign     = t.align;
}

/* ── Apply TABLE_STYLE to a .data-box + its table ── */
function applyTableStyle(boxEl) {
  if (!boxEl) return;
  const ts = TABLE_STYLE;
  boxEl.style.border       = `${ts.boxBorderWidth} solid ${ts.boxBorderColor}`;
  boxEl.style.borderRadius = ts.boxBorderRadius;
}

/* ── Apply LAYOUT ── */
function applyLayout() {
  const card = document.getElementById('card');
  const wrap = document.getElementById('donutWrap');
  const info = document.getElementById('infoCol');
  const cW = card.offsetWidth, cH = card.offsetHeight;
  const d  = (LAYOUT.donutDiameter / 100) * cW;
  const cx = (LAYOUT.donutCenterX  / 100) * cW;
  const cy = (LAYOUT.donutCenterY  / 100) * cH;
  wrap.style.width  = d + 'px';  wrap.style.height = d + 'px';
  wrap.style.left   = (cx - d / 2) + 'px';  wrap.style.top = (cy - d / 2) + 'px';
  info.style.left   = ((LAYOUT.panelLeft   / 100) * cW) + 'px';
  info.style.top    = ((LAYOUT.panelTop    / 100) * cH) + 'px';
  info.style.right  = ((LAYOUT.panelRight  / 100) * cW) + 'px';
  info.style.bottom = ((LAYOUT.panelBottom / 100) * cH) + 'px';
}

/* ── Apply VERDICT_POS geometry & positioning ONLY ── */
function applyVerdictPos(vb, pass) {
  const card = document.getElementById('card');
  const cW = card.offsetWidth;
  const cH = card.offsetHeight;
  const vp = VERDICT_POS;
  const vt = TYPOGRAPHY.verdict;

  /* Typography */
  applyT(vb, vt);

  /* Geometry */
  vb.style.padding   = `${vp.paddingV}px ${vp.paddingH}px`;
  vb.style.textAlign = vp.textAlign;

  if (vp.minWidth  > 0) vb.style.minWidth  = vp.minWidth  + 'px';
  if (vp.minHeight > 0) vb.style.minHeight = vp.minHeight + 'px';

  /* Measure badge */
  vb.style.visibility = 'hidden';
  vb.style.left = '0';
  vb.style.top  = '0';
  vb.style.right = '';
  vb.style.bottom = '';

  const bW = vb.offsetWidth;
  const bH = vb.offsetHeight;

  vb.style.visibility = '';

  /* Anchor math */
  const ax = (vp.anchorX / 100) * cW;
  const ay = (vp.anchorY / 100) * cH;

  const a  = vp.anchor || 'top-right';
  const hP = a.includes('left') ? 0 : a.includes('right') ? 1 : 0.5;
  const vP = a.includes('bottom') ? 1 : 0;

  vb.style.left   = (ax - hP * bW) + 'px';
  vb.style.top    = (ay - vP * bH) + 'px';
}

/* ── Update source swatches without re-render ── */
function updateSourceColors(pal) {
  const swatches = document.querySelectorAll('#sourcesBody .swatch');

  swatches.forEach((sw, i) => {
    sw.style.background =
      i < pal.length ? pal[i] : '#cccccc';
  });
}


/* ── Update source swatches + table colors without re-render ── */
function updateSourceColors(pal) {
  const swatches = document.querySelectorAll('#sourcesBody .swatch');

  swatches.forEach((sw, i) => {
    sw.style.background =
      i < pal.length ? pal[i] : '#cccccc';
  });
}


/* ── Soft-break long names ── */
function softBreak(s) { return s.replace(/([_.\-])/g, '$1<wbr>'); }

/* ── Merge row override with defaults ── */
function mergeRow(i) {
  const base = {
    nameFont:           TYPOGRAPHY.sourcesName.font,
    nameFontSize:       TYPOGRAPHY.sourcesName.fontSize,
    nameFontWeight:     TYPOGRAPHY.sourcesName.fontWeight,
    nameFontStyle:      TYPOGRAPHY.sourcesName.fontStyle      || 'normal',
    nameColor:          TYPOGRAPHY.sourcesName.color,
    nameLetterSpacing:  TYPOGRAPHY.sourcesName.letterSpacing  || '0',
    nameLineHeight:     TYPOGRAPHY.sourcesName.lineHeight      || '1.35',
    nameAlign:          TYPOGRAPHY.sourcesName.align,
    coeffFont:          TYPOGRAPHY.sourcesCoeff.font,
    coeffFontSize:      TYPOGRAPHY.sourcesCoeff.fontSize,
    coeffFontWeight:    TYPOGRAPHY.sourcesCoeff.fontWeight,
    coeffFontStyle:     TYPOGRAPHY.sourcesCoeff.fontStyle     || 'normal',
    coeffColor:         TYPOGRAPHY.sourcesCoeff.color,
    coeffLetterSpacing: TYPOGRAPHY.sourcesCoeff.letterSpacing || '0',
    coeffAlign:         TYPOGRAPHY.sourcesCoeff.align,
    zFont:              TYPOGRAPHY.sourcesZ.font,
    zFontSize:          TYPOGRAPHY.sourcesZ.fontSize,
    zFontWeight:        TYPOGRAPHY.sourcesZ.fontWeight,
    zFontStyle:         TYPOGRAPHY.sourcesZ.fontStyle         || 'normal',
    zLetterSpacing:     TYPOGRAPHY.sourcesZ.letterSpacing     || '0',
    zGap:               TYPOGRAPHY.sourcesZ.zGap,
  };
  const ov = TYPOGRAPHY.sourcesRowOverrides.find(r => r.index === i);
  return ov ? Object.assign({}, base, ov) : base;
}

function isRawFormat(t) { return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t); }

function parseRaw(text) {
  const lines = text.split('\n');
  const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
  if (li < 0) throw new Error('"left pops:" not found');
  const lp = [];
  for (let i = li+1; i < lines.length; i++) {
    const l = lines[i].trim();
    if (!l || /^right pops/i.test(l)) break;
    const m = l.match(/^(\S+)\s+\d+/); if (m) lp.push(m[1]);
  }
  if (lp.length < 2) throw new Error('Need target + ≥1 source in left pops');
  const target = lp[0], sources = lp.slice(1);
  const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
  const rp = [];
  if (ri >= 0) {
    for (let i = ri+1; i < lines.length; i++) {
      const l = lines[i].trim();
      if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
      const m = l.match(/^(\S+)\s+\d+/); if (m) rp.push(m[1]);
    }
  }
  let pValue = NaN, chisq = NaN;
  const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
  if (ci >= 0) {
    for (let i = ci+1; i < Math.min(ci+6, lines.length); i++) {
      const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
    }
  }
  if (isNaN(pValue)) {
    for (const l of lines) {
      const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
    }
  }
  if (isNaN(pValue)) throw new Error('Could not parse p-value');
  const cl = lines.find(l => /best coefficients:/.test(l));
  if (!cl) throw new Error('"best coefficients:" not found');
  const coeffs = cl.replace('best coefficients:','').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (coeffs.length !== sources.length) throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);
  const sl = lines.find(l => /std\.\s*errors:/.test(l));
  if (!sl) throw new Error('"std. errors:" not found');
  const ses = sl.replace(/std\.\s*errors:/,'').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (ses.length !== sources.length) throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);
  const tot = coeffs.reduce((a,b)=>a+b,0);
  return { target, sources,
    weights: coeffs.map(c=>(c/tot)*100), sesPct: ses.map(s=>s*100),
    zScores: coeffs.map((c,i)=>ses[i]>0?c/ses[i]:0),
    pValue, chisq, outgroups: rp.join(', ') };
}

function parseSummary(text) {
  const lines = text.split('\n').map(l=>l.trim()).filter(Boolean);
  const tl = lines.find(l=>l.startsWith('Target:'));
  if (!tl) throw new Error('Target line not found');
  const target = tl.replace('Target:','').trim();
  const ws = lines.findIndex(l=>l.startsWith('Weights:'));
  if (ws < 0) throw new Error('Weights section not found');
  const pvl = lines.find(l=>l.startsWith('P value:')), chl = lines.find(l=>l.startsWith('chisq:'));
  if (!pvl) throw new Error('P value not found'); if (!chl) throw new Error('chisq not found');
  const pValue = parseFloat(pvl.replace('P value:','').trim());
  const chisq  = parseFloat(chl.replace('chisq:','').trim());
  const rgl    = lines.find(l=>l.startsWith('Rights:'));
  const outgroups = rgl ? rgl.replace('Rights:','').trim() : '';
  const sources=[],weights=[],sesPct=[],zScores=[];
  for (let i=ws+1; i<lines.length; i++) {
    const l = lines[i];
    if (/^(P value:|chisq:|Rights:)/.test(l)) break;
    const m = l.match(/^(.+?)\s*-\s*([\d.]+)%\s*SE:\s*([\d.]+)%\s*Z:\s*([-\d.]+)/);
    if (m) { sources.push(m[1].trim()); weights.push(parseFloat(m[2])); sesPct.push(parseFloat(m[3])); zScores.push(parseFloat(m[4])); }
  }
  if (!sources.length) throw new Error('No populations found');
  const tot = weights.reduce((a,b)=>a+b,0);
  return { target, sources, weights: weights.map(w=>(w/tot)*100), sesPct, zScores, pValue, chisq, outgroups };
}

function zClass(z) { return z >= CFG.zGoodMin ? 'z-good' : (z >= CFG.zMidMin ? 'z-mid' : 'z-bad'); }

/* ═══ MAIN RENDER ═══ */
function parseAndDraw() {
  const text = document.getElementById('qpadmText').value.trim();
  document.getElementById('card').style.display        = 'none';
  document.getElementById('downloadBtn').style.display = 'none';

  try {
    let parsed, fmtTxt, fmtCls;
    if (isRawFormat(text)) { parsed = parseRaw(text);     fmtTxt = '⚙ Raw log'; fmtCls = 'raw'; }
    else                   { parsed = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = ''; }
    const badge = document.getElementById('formatBadge');
    badge.textContent = fmtTxt; badge.className = fmtCls; badge.style.display = 'inline-block';

    const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;

    /* ── Complexity warning ── */
    const isOverComplex = sources.length > 6;
    if (isOverComplex) {
      console.warn(
        'qpAdm model uses >6 sources — interpretability reduced.'
      );
    }


    /* ── Header padding ── */
    const hp = TYPOGRAPHY.headerPadding;
    document.getElementById('cardHeader').style.padding = `${hp.top} ${hp.sides} ${hp.bottom} ${hp.sides}`;

    /* ── Target ── */
    const tEl = document.getElementById('cardTarget');
    tEl.textContent = 'Target: ' + target;
    applyT(tEl, TYPOGRAPHY.target);

    /* ── Stat line ── */
    const pd   = pValue < 0.0001 ? pValue.toExponential(4) : parseFloat(pValue.toPrecision(7)).toString();
    const slEl = document.getElementById('statLine');
    slEl.innerHTML = `χ² = ${chisq.toFixed(2)}<span class="stat-sep"> / </span>p = ${pd}`;
    applyT(slEl, TYPOGRAPHY.stat);
    slEl.style.marginTop = TYPOGRAPHY.stat.marginTop || '2px';

    /* ── Show card (needed for measurements) ── */
    document.getElementById('card').style.display = 'block';

    /* ── Verdict badge ── */
    /* ── Advanced verdict logic ── */
    const minAbsZ   = Math.min(...zScores.map(z => Math.abs(z)));
    const minWeight = Math.min(...weights);
    const maxRelSE  = Math.max(...sesPct.map((se, i) =>
      weights[i] > 1 ? se / weights[i] : Infinity
    ));

    let verdictType;
    let verdictText;

    /* FAIL */
    /* FAIL */
    if (
      pValue < 0.05 ||
      minAbsZ < 2.0 ||
      minWeight < -5 ||
      maxRelSE > 1.5
    ) {
      verdictType = 'fail';
      verdictText = 'FAIL';
    }

    /* PASS (strong) */
    else if (
      minAbsZ >= 3.0 &&
      maxRelSE < 0.5 &&
      weights.length <= 4
    ) {
      verdictType = 'pass';
      verdictText = 'PASS';
    }

    /* PASS* (weak) */
    else {
      verdictType = 'weak';
      verdictText = 'PASS*';
    }


    const vb = document.getElementById('verdictBadge');
    vb.textContent = verdictText;

    /* ── Apply verdict styling ── */
    vb.dataset.verdict = verdictType;
    applyT(vb, TYPOGRAPHY.verdict);

    switch (verdictType) {
      case 'pass':
        vb.style.background = VERDICT_POS.passBg;
        vb.style.color      = VERDICT_POS.passText;
        applyVerdictPos(vb, true);
        break;

      case 'weak':
        vb.style.background = VERDICT_POS.weakBg;
        vb.style.color      = VERDICT_POS.weakText;
        applyVerdictPos(vb, true);
        break;

      default:
        vb.style.background = VERDICT_POS.failBg;
        vb.style.color      = VERDICT_POS.failText;
        applyVerdictPos(vb, false);
    }

    /* ── Layout ── */
    applyLayout();

    /* ── Table styles ── */
    applyTableStyle(document.getElementById('sourcesBox'));
    applyTableStyle(document.getElementById('outgroupsBox'));

    /* ── Colors ── */
    const pidx   = parseInt(document.getElementById('paletteSelect').value);
    const pal    = colorPalettes[pidx];

    /* ── Disable palette selection if model exceeds palette capacity ── */
    if (sources.length > pal.length) {
      console.warn(
        'Palette has fewer colors than sources; extra sources rendered in grey.'
      );
    }

    const colors = sources.map((_, i) =>   i < pal.length ? pal[i] : '#cccccc');


    /* ── Donut ── */
    const ctx = document.getElementById('donutChart').getContext('2d');
    if (chartObj) chartObj.destroy();
    chartObj = new Chart(ctx, {
      type: 'doughnut',
      data: { labels: sources, datasets: [{
        data: weights,
        backgroundColor: colors, hoverBackgroundColor: colors,
        borderColor: CFG.donutBorderC, hoverBorderColor: CFG.donutBorderC,
        borderWidth: CFG.donutBorderW, hoverBorderWidth: CFG.donutBorderW,
        hoverOffset: CFG.donutHoverOff,
      }]},
      options: {
        responsive: true, cutout: CFG.donutCutout,
        rotation: CFG.donutStartAngle,
        circumference: CFG.donutClockwise ? 360 : -360,
        layout: { padding: CFG.donutHoverOff },
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` } }
        },
        animation: { animateRotate: true, duration: 550 }
      }
    });

    /* ══ SOURCES TABLE ══════════════════════════════════════════════════════
       HEADER: single <th colspan="3"> spanning ALL columns (swatch+name+data)
       so it is always centred over the full table width.
       The swatch-column width is enforced by the first data row.
       ═══════════════════════════════════════════════════════════════════════ */
    const ts     = TABLE_STYLE;
    const sh     = TYPOGRAPHY.sourcesHeader;
    const swColW = (parseInt(SWATCH.width) + 16) + 'px';

    /* Header: colspan=3, spans entire table — true visual centre */
    document.getElementById('sourcesHead').innerHTML = `
      <tr>
        <th colspan="3" style="
          font-family:${sh.font};font-size:${sh.fontSize};
          font-weight:${sh.fontWeight};font-style:${sh.fontStyle||'normal'};
          color:${sh.color};letter-spacing:${sh.letterSpacing};
          line-height:${sh.lineHeight};text-align:${sh.align};
          text-transform:${sh.textTransform||'uppercase'};
          background:${ts.headerBg};
          border-bottom:${ts.headerBorderWidth} solid ${ts.headerBorderColor};
          padding:5px 10px;white-space:nowrap;
        ">${sh.text}</th>
      </tr>`;

    /* ── Source rows ── */
    const zT  = TYPOGRAPHY.sourcesZ;
    const sc  = TYPOGRAPHY.sourcesColon;
    let srcHTML = '';

    sources.forEach((pop, i) => {
      const rs    = mergeRow(i);
      const z     = zScores[i];
      const zCl   = zClass(z);
      const rowBg = (i % 2 === 0) ? ts.evenRowBg : ts.oddRowBg;
      const sepBorder = `border-bottom:${ts.rowBorderWidth} solid ${ts.rowBorderColor};`;

      /* ── Z block: (Z: 12.41) — simple inline, no grid hack ──
         Plain inline rendering eliminates the vertical-shift artefact.  */
      const zHtml = `<span class="${zCl}" style="
          font-family:${rs.zFont};font-size:${rs.zFontSize};
          font-weight:${rs.zFontWeight};font-style:${rs.zFontStyle};
          letter-spacing:${rs.zLetterSpacing};
          white-space:nowrap;vertical-align:baseline;
        ">(${zT.zPrefix}${z.toFixed(2)})</span>`;

      /* ── zSepPx: controlled gap between coeff value and Z bracket ── */
      const zSepHtml = `<span style="display:inline-block;width:${zT.zSepPx}px;"></span>`;

      /* ── Colon separator ── */
      const colonHtml = `<span style="font-family:${sc.colonFont};color:${sc.colonColor};white-space:pre;">${sc.colonText}</span>`;

      /* ── Coeff value ── */
      const coeffHtml = `<span style="
          font-family:${rs.coeffFont};font-size:${rs.coeffFontSize};
          font-weight:${rs.coeffFontWeight};font-style:${rs.coeffFontStyle};
          color:${rs.coeffColor};letter-spacing:${rs.coeffLetterSpacing};
          white-space:nowrap;vertical-align:baseline;
        ">${weights[i].toFixed(1)}% \u00B1 ${sesPct[i].toFixed(2)}%</span>`;

      /* Full data cell: ": coeff ± se  [gap]  (Z: 12.41)" */
      const dataHtml = `${colonHtml}${coeffHtml}${zSepHtml}${zHtml}`;

      srcHTML += `<tr style="background:${rowBg};">
        <td class="col-sw" style="
          width:${swColW};padding:5px 0 5px 10px !important;
          vertical-align:middle;${sepBorder}
          background:${ts.cellBg !== 'transparent' ? ts.cellBg : rowBg};
        ">
          <span class="swatch" style="
            background:${colors[i]};
            width:${SWATCH.width};height:${SWATCH.height};
            border-radius:${SWATCH.radius};border:${SWATCH.border};
          "></span>
        </td>
        <td class="col-name" style="
          text-align:${rs.nameAlign};padding:5px 4px !important;
          vertical-align:middle;${sepBorder}
          background:${ts.cellBg !== 'transparent' ? ts.cellBg : rowBg};
        ">
          <span class="pop-name" style="
            font-family:${rs.nameFont};font-size:${rs.nameFontSize};
            font-weight:${rs.nameFontWeight};font-style:${rs.nameFontStyle};
            color:${rs.nameColor};letter-spacing:${rs.nameLetterSpacing};
            line-height:${rs.nameLineHeight};
          ">${softBreak(pop)}</span>
        </td>
        <td class="col-data" style="
          text-align:${rs.coeffAlign};white-space:nowrap;
          padding:5px 10px;vertical-align:middle;${sepBorder}
          background:${ts.cellBg !== 'transparent' ? ts.cellBg : rowBg};
        ">${dataHtml}</td>
      </tr>`;
    });

    /* Remove bottom border from last row */
    srcHTML = srcHTML.replace(/border-bottom:[^;]+;(<\/td>\s*<\/tr>\s*)$/, '$1');
    document.getElementById('sourcesBody').innerHTML = srcHTML;

    /* ── Outgroups ── */
    const ogBox = document.getElementById('outgroupsBox');
    const ogTd  = document.getElementById('outgroupsTd');
    const ogH   = document.getElementById('hdrOutgroups');
    const ogh   = TYPOGRAPHY.outgroupsHeader;
    const ogc   = TYPOGRAPHY.outgroupsCell;
    if (outgroups) {
      ogH.textContent = ogh.text;
      applyT(ogH, ogh);
      ogH.style.textTransform = ogh.textTransform || 'uppercase';
      ogH.style.padding    = '5px 10px';
      ogH.style.background = ts.headerBg;
      ogH.style.borderBottom = `${ts.headerBorderWidth} solid ${ts.headerBorderColor}`;
      applyT(ogTd, ogc);
      ogTd.style.padding    = '5px 10px';
      ogTd.style.background = ts.cellBg;
      ogTd.textContent    = outgroups;
      ogBox.style.display = 'block';
    } else {
      ogBox.style.display = 'none';
    }

    /* ── Watermark ── */
    const wEl = document.getElementById('watermark');
    applyT(wEl, TYPOGRAPHY.watermark);
    const tg = document.getElementById('telegramInput').value.trim();
    const xw = document.getElementById('xInput').value.trim();
    const dc = document.getElementById('discordInput').value.trim();
    const pts = [];
    if (tg) pts.push('TG: '+tg);
    if (xw) pts.push('X: '+xw);
    if (dc) pts.push('DC: '+dc);
    wEl.textContent = pts.join('  \u00B7  ');

    document.getElementById('downloadBtn').style.display = 'inline-block';

  } catch(e) { alert('Parse error:\n\n'+e.message); console.error(e); }
}

document.getElementById('paletteSelect')
  .addEventListener('change', () => {

    if (!chartObj) return;

    const pidx = parseInt(
      document.getElementById('paletteSelect').value
    );
    const pal = colorPalettes[pidx];

    const labels = chartObj.data.labels;
    const colors = labels.map((_, i) =>
      i < pal.length ? pal[i] : '#cccccc'
    );

    chartObj.data.datasets[0].backgroundColor = colors;
    chartObj.data.datasets[0].hoverBackgroundColor = colors;

    chartObj.update();

    updateSourceColors(pal);
  });
  window.addEventListener('resize', () => {
  if (document.getElementById('card').style.display !== 'none') {
    applyLayout();
    const vb   = document.getElementById('verdictBadge');
    const pass = vb.textContent === 'PASS';
    if (vb.textContent) applyVerdictPos(vb, pass);
  }
});

function downloadImage() {
  const card = document.getElementById('card');
  card.style.overflow = 'hidden';
  html2canvas(card, { scale: 3, backgroundColor: '#ffffff', useCORS: true })
    .then(canvas => {
      card.style.overflow = '';
      const a = document.createElement('a');
      a.download = 'qpAdm_chart.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
}
</script>
</body>
</html>