<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>qpViz — Admixture Visualization Tool</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,400&family=DM+Mono:wght@400;500&family=Fira+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --ui-bg:       #0e0e0f;
      --ui-surface:  #17171a;
      --ui-border:   #252528;
      --ui-border-h: #3a3a3e;
      --ui-text:     #e2e2e6;
      --ui-muted:    #6b6b72;
      --ui-accent:   #6366f1;
      --ui-accent-h: #818cf8;
    }

    body {
      min-height: 100vh;
      background: var(--ui-bg);
      font-family: 'Roboto', sans-serif;
      color: var(--ui-text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 32px 20px 64px;
      gap: 24px;
    }

    /* ─── App header ─── */
    .app-header { width: 100%; max-width: 1040px; display: flex; flex-direction: column; gap: 4px; }
    .app-header-row { display: flex; align-items: baseline; gap: 14px; flex-wrap: wrap; }
    .app-title { font-size: 2rem; font-weight: 900; color: #fff; letter-spacing: -0.03em; }
    .app-title span { color: var(--ui-accent-h); }
    .app-badge {
      font-size: 10px; font-weight: 700; letter-spacing: 0.18em; text-transform: uppercase;
      color: var(--ui-muted); background: var(--ui-surface);
      border: 1px solid var(--ui-border); border-radius: 3px; padding: 3px 8px;
    }
    .app-desc {
      font-size: 12px; color: var(--ui-muted);
      letter-spacing: 0.01em; line-height: 1.65; max-width: 640px;
    }

    /* ─── Input panel ─── */
    .input-panel { width: 100%; max-width: 1040px; display: flex; flex-direction: column; gap: 10px; }
    .textarea-wrap { position: relative; }
    textarea {
      width: 100%; height: 148px;
      background: var(--ui-surface); border: 1px solid var(--ui-border);
      border-radius: 5px; color: #c8c8c8;
      font-family: 'DM Mono', monospace; font-size: 11.5px; line-height: 1.7;
      padding: 12px 14px; resize: vertical; outline: none;
      transition: border-color 0.15s;
    }
    textarea:focus { border-color: var(--ui-border-h); }
    textarea::placeholder { color: #2a2a2c; }
    .paste-hint {
      position: absolute; bottom: 8px; right: 10px;
      font-size: 10px; color: #2a2a2c; pointer-events: none;
    }

    /* ─── Controls ─── */
    .controls-row { display: flex; gap: 7px; flex-wrap: wrap; align-items: center; }
    .ctrl-sep { width: 1px; height: 26px; background: var(--ui-border); flex-shrink: 0; }
    .ctrl-label {
      font-size: 10.5px; font-weight: 600; color: var(--ui-muted);
      letter-spacing: 0.08em; text-transform: uppercase; white-space: nowrap;
    }
    .ctrl-group { display: flex; align-items: center; gap: 5px; }

    /* Buttons */
    .btn {
      padding: 7px 14px; border: none; border-radius: 4px;
      font-size: 12.5px; font-weight: 600; cursor: pointer;
      letter-spacing: 0.01em;
      transition: background 0.13s, color 0.13s, border-color 0.13s;
      white-space: nowrap; line-height: 1;
    }
    .btn-primary { background: #f0f0f0; color: #111; }
    .btn-primary:hover { background: #fff; }
    .btn-ghost { background: var(--ui-surface); color: var(--ui-muted); border: 1px solid var(--ui-border); }
    .btn-ghost:hover { border-color: var(--ui-border-h); color: var(--ui-text); }
    .btn-upload { background: var(--ui-surface); color: #7dd3fc; border: 1px solid #1e3a4a; }
    .btn-upload:hover { border-color: #38bdf8; color: #38bdf8; }
    .btn-dl { background: var(--ui-accent); color: #fff; display: none; }
    .btn-dl:hover { background: var(--ui-accent-h); }
    .btn-dl:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-toggle {
      background: var(--ui-surface); color: var(--ui-muted);
      border: 1px solid var(--ui-border); font-size: 11.5px;
    }
    .btn-toggle.active { background: #1e2a1e; color: #4ade80; border-color: #2a4a2a; }
    .btn-toggle:hover:not(.active) { border-color: var(--ui-border-h); }

    /* Selects & number input */
    select, .ctrl-input {
      background: var(--ui-surface); border: 1px solid var(--ui-border);
      border-radius: 4px; color: #bbb; font-size: 12px; padding: 7px 9px;
      cursor: pointer; outline: none; transition: border-color 0.13s;
    }
    select:hover, select:focus,
    .ctrl-input:hover, .ctrl-input:focus { border-color: var(--ui-border-h); }
    .ctrl-input-num {
      width: 54px; text-align: center;
      font-family: 'DM Mono', monospace;
    }

    /* Format badge */
    #formatBadge {
      display: none; font-size: 10px; font-weight: 700; padding: 4px 10px;
      border-radius: 3px; letter-spacing: 0.07em; text-transform: uppercase;
      background: #0d2b18; color: #4ade80;
    }
    #formatBadge.raw   { background: #2b1800; color: #fb923c; }
    #formatBadge.error { background: #2e1010; color: #f87171; }

    /* ══════════════════════════════════
       CARD
    ══════════════════════════════════ */
    #card {
      width: 100%; max-width: 1040px;
      border-radius: 6px; display: none;
      position: relative; overflow: visible;
      box-shadow: 0 24px 80px rgba(0,0,0,0.7);
    }
    .card-bg { position: absolute; inset: 0; border-radius: 6px; z-index: 0; pointer-events: none; }

    /* Card header */
    .card-header {
      position: absolute; top: 0; left: 0; right: 0;
      display: flex; flex-direction: column; align-items: center; z-index: 2;
    }
    #cardTarget { width: 100%; }
    .stat-sep { color: #bbb; margin: 0 8px; }

    /* Verdict badge */
    .verdict-badge { position: absolute; border: none; border-radius: 0; text-transform: uppercase; z-index: 3; }

    /* Donut wrapper */
    #donutWrap { position: absolute; z-index: 10; }
    #donutWrap canvas { width: 100% !important; height: 100% !important; display: block; }

    /* Info panel */
    .info-col {
      position: absolute; display: flex; flex-direction: column;
      justify-content: center; gap: 10px; min-width: 0; z-index: 2; overflow: hidden;
    }

    /* Tables (desktop) */
    .data-box   { overflow: hidden; }
    .data-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    .col-sw-col   { width: 40px; }
    .col-name-col { width: auto; }
    .col-data-col { width: 220px; }
    .col-sw, .col-name, .col-data { vertical-align: middle; }
    .swatch   { display: inline-block; vertical-align: middle; flex-shrink: 0; }
    .pop-name { vertical-align: middle; hyphens: none; line-height: 1.35; }
    .outgroups-td { white-space: normal; word-break: break-word; overflow-wrap: break-word; }

    /* Watermark */
    .watermark {
      position: absolute;
      bottom: 0;
      right: 0;
      z-index: 5;
      pointer-events: none;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: flex-end;
    }
    .watermark .sig-ch { display: block; line-height: 1; }

    /* Stacked layout (portrait / square) */
    #card.stacked .col-data-col { width: auto; }
    #card.stacked .info-col { justify-content: flex-start; }
    #card.stacked .data-table { table-layout: auto; }
  </style>
</head>
<body>

<!-- ══ HEADER ══════════════════════════════════════════════════════════════ -->
<div class="app-header">
  <div class="app-header-row">
    <h1 class="app-title">qp<span>Viz</span></h1>
    <span class="app-badge">qpAdm Visualizer</span>
  </div>
  <p class="app-desc">
    Paste raw qpAdm log output or a compact summary to generate a publication-ready
    admixture chart. Supports both formats, 19 colour palettes, light&nbsp;&amp;&nbsp;dark card
    themes, five aspect ratios for print, slides, and social media, configurable
    donut direction, and live percentage labels.
  </p>
</div>

<!-- ══ INPUT PANEL ═════════════════════════════════════════════════════════ -->
<div class="input-panel">
  <div class="textarea-wrap">
    <textarea id="qpadmText"
      placeholder="Paste raw qpAdm log or pre-formatted summary…

RAW LOG:   left pops / right pops / best coefficients / std. errors / f4rank block
SUMMARY:   Target: X
           Weights:
           PopA - 43.8% SE: 3.78% Z: 11.57
           P value: 0.178 | chisq: 4.12 | Rights: Mbuti, Yoruba, …

Ctrl+Enter → generate   ·   Ctrl+O → upload file"></textarea>
    <span class="paste-hint">Ctrl+Enter · generate</span>
  </div>

  <div class="controls-row">
    <!-- Primary actions -->
    <button class="btn btn-primary" onclick="parseAndDraw()">Generate</button>
    <button class="btn btn-ghost"   onclick="loadExample()">Example</button>
    <button class="btn btn-upload"  onclick="document.getElementById('fileInput').click()">↑ Upload</button>
    <input type="file" id="fileInput"
           accept=".log,.txt,.raw,.text,.out,text/plain"
           style="display:none" onchange="handleFileUpload(event)">

    <div class="ctrl-sep"></div>

    <!-- Palette -->
    <select id="paletteSelect">
      <optgroup label="── Universal ──">
        <option value="0">qpAdm Classic</option>
        <option value="1">ColorBrewer Set1</option>
        <option value="2">Tableau 10</option>
        <option value="3">Dark2</option>
        <option value="4">Earth / Archaeogenetics</option>
        <option value="5">Soft Modern</option>
        <option value="11">Okabe-Ito ✦ colorblind</option>
        <option value="12">Paul Tol Bright ✦ colorblind</option>
        <option value="13">ISBA / Reich Lab</option>
        <option value="14">Desaturated Pastel</option>
        <option value="15">Nature / Science</option>
      </optgroup>
      <optgroup label="── Light card ──">
        <option value="6">Greyscale High Contrast</option>
        <option value="7">Greyscale Journal</option>
        <option value="8">Greyscale Soft</option>
        <option value="9">Blue Scale</option>
        <option value="10">Green Scale</option>
      </optgroup>
      <optgroup label="── Dark card ──">
        <option value="16">Neon Vivid ◆</option>
        <option value="17">Pastel Vivid ◆</option>
        <option value="18">Midnight Ocean ◆</option>
      </optgroup>
    </select>

    <!-- Theme -->
    <div class="ctrl-group">
      <span class="ctrl-label">Theme</span>
      <select id="themeSelect" onchange="onThemeChange(this.value)">
        <option value="light">☀ Light</option>
        <option value="dark">◑ Dark</option>
      </select>
    </div>

    <div class="ctrl-sep"></div>

    <!-- Aspect ratio -->
    <div class="ctrl-group">
      <span class="ctrl-label">Ratio</span>
      <select id="ratioSelect" onchange="onRatioChange(this.value)">
        <option value="landscape-wide" data-ar="16 / 10.5">Default (16:10.5)</option>
        <option value="landscape-169"  data-ar="16 / 9">Widescreen (16:9)</option>
        <option value="landscape-43"   data-ar="4 / 3">Standard (4:3)</option>
        <option value="square"         data-ar="1 / 1">Square (social)</option>
        <option value="portrait"       data-ar="9 / 16">Portrait (story)</option>
      </select>
    </div>

    <!-- Donut hole size -->
    <div class="ctrl-group">
      <span class="ctrl-label">Hole</span>
      <input type="number" id="cutoutInput" class="ctrl-input ctrl-input-num"
             min="20" max="90" value="65" step="1"
             oninput="onCutoutChange(this.value)"
             title="Donut hole size — 20 to 90 %">
      <span class="ctrl-label">%</span>
    </div>

    <!-- Donut direction -->
    <div class="ctrl-group">
      <span class="ctrl-label">Dir</span>
      <button class="btn btn-toggle" id="cwToggle"
              onclick="toggleClockwise()"
              title="Toggle donut segment direction: clockwise / counter-clockwise">
        ↻ CW
      </button>
    </div>

    <!-- Percentage labels inside donut -->
    <button class="btn btn-toggle" id="labelToggle"
            onclick="toggleLabels()"
            title="Show / hide % labels inside the donut">
      % labels
    </button>

    <div class="ctrl-sep"></div>

    <span id="formatBadge"></span>
    <button class="btn btn-dl" id="downloadBtn" onclick="downloadImage()">↓ PNG</button>
  </div>
</div>

<!-- ══ CARD ════════════════════════════════════════════════════════════════ -->
<div id="card">
  <div class="card-bg" id="cardBg"></div>
  <div class="card-header" id="cardHeader">
    <div id="cardTarget"></div>
    <div id="statLine"></div>
    <div class="verdict-badge" id="verdictBadge"></div>
  </div>
  <div id="donutWrap"><canvas id="donutChart" role="img"></canvas></div>
  <div class="info-col" id="infoCol">
    <!-- Sources box: desktop renders a <table>, mobile renders stacked div cards -->
    <div class="data-box" id="sourcesBox"></div>
    <!-- Outgroups box -->
    <div class="data-box" id="outgroupsBox" style="display:none;">
      <table class="data-table" id="outgroupsTable">
        <thead><tr><th id="hdrOutgroups"></th></tr></thead>
        <tbody><tr><td class="outgroups-td" id="outgroupsTd"></td></tr></tbody>
      </table>
    </div>
    <div id="outgroupsFoot" style="display:none;"></div>
  </div>
  <div class="watermark" id="watermark"></div>
</div>

<script>

/* ─── Register datalabels plugin ─── */
Chart.register(ChartDataLabels);

/* ═══════════════════════════════════════════════════════════════════════
   LAYOUT PROFILES
═══════════════════════════════════════════════════════════════════════ */
const LAYOUT_PROFILES = {
  'landscape-wide': {
    donutCenterX: 23, donutCenterY: 55, donutDiameter: 43,
    panelLeft: 48, panelTop: 18, panelRight: 2, panelBottom: 3,
    stacked: false,
  },
  'landscape-169': {
    donutCenterX: 22, donutCenterY: 57, donutDiameter: 40,
    panelLeft: 46, panelTop: 15, panelRight: 2, panelBottom: 3,
    stacked: false,
  },
  'landscape-43': {
    donutCenterX: 24, donutCenterY: 54, donutDiameter: 46,
    panelLeft: 50, panelTop: 18, panelRight: 2, panelBottom: 3,
    stacked: false,
  },
  'square': {
    donutCenterX: 50, donutCenterY: 35, donutDiameter: 50,
    panelLeft: 4, panelTop: 60, panelRight: 4, panelBottom: 2,
    stacked: true,
  },
  'portrait': {
    donutCenterX: 50, donutCenterY: 30, donutDiameter: 62,
    panelLeft: 3, panelTop: 52, panelRight: 3, panelBottom: 2,
    stacked: true,
  },
};

let activeLayout = 'landscape-wide';

/* ═══════════════════════════════════════════════════════════════════════
   CARD
═══════════════════════════════════════════════════════════════════════ */
const CARD = { bgColor: '#ffffff', aspectRatio: '16 / 10.5' };

/* ═══════════════════════════════════════════════════════════════════════
   VERDICT BADGE
═══════════════════════════════════════════════════════════════════════ */
const VERDICT_POS = {
  anchorX: 98, anchorY: 3, anchor: 'top-right',
  minWidth: 0, minHeight: 0, paddingV: 8, paddingH: 8, textAlign: 'center',
  passBg: '#f3fefd', passText: '#3a9063',
  weakBg: '#fefce8', weakText: '#ca8a04',
  failBg: '#FFFAFA', failText: '#dc2626',
};

/* ═══════════════════════════════════════════════════════════════════════
   VERDICT THRESHOLDS
═══════════════════════════════════════════════════════════════════════ */
const VERDICT_CFG = {
  pValueFail:       0.05,
  minZFail:         2.0,
  minWeightFail:   -5,
  maxRelSEFail:     1.5,
  minWtForSE:       2,
  minZStrong:       3.0,
  maxRelSEStrong:   0.5,
  maxSourcesStrong: 4,
};

/* ═══════════════════════════════════════════════════════════════════════
   Z-SCORE TIER COLOURS
   Note: these are mutated by applyTheme() — do not read them before
   the theme is applied. Dark theme uses higher-contrast variants.
═══════════════════════════════════════════════════════════════════════ */
const Z_COLORS = { zGood: '#16a34a', zMid: '#ca8a04', zBad: '#dc2626' };

/* ═══════════════════════════════════════════════════════════════════════
   TABLE STYLE (colours mutated by applyTheme)
═══════════════════════════════════════════════════════════════════════ */
const TABLE_STYLE = {
  boxBorderWidth:    '1.5px',
  boxBorderColor:    '#d1d5db',
  boxBorderRadius:   '2px',
  headerBg:          '#f3f4f6',
  headerBorderWidth: '1.5px',
  headerBorderColor: '#d1d5db',
  rowBorderWidth:    '1px',
  rowBorderColor:    '#e5e7eb',
  cellBg:            'transparent',
  evenRowBg:         'transparent',
  oddRowBg:          'transparent',
};

/* ═══════════════════════════════════════════════════════════════════════
   TABLE ROUNDNESS CONTROLS
   Separate control for sources/outgroups in:
   - global (non-mobile, non-square)
   - mobile
   - square
═══════════════════════════════════════════════════════════════════════ */
const TABLE_RADIUS = {
  globalSources:  '2px',
  globalOutgroups:'2px',
  mobileSources:  '8px',
  mobileOutgroups:'8px',
  squareSources:  '8px',
  squareOutgroups:'8px',
};

/* ═══════════════════════════════════════════════════════════════════════
   DONUT CONFIG

   donutClockwise: true  → segments rendered in original data order (CW)
                   false → segments rendered in reversed data order (CCW)
                   Direction is achieved by reversing the data array, NOT
                   by using negative circumference. This keeps colors bound
                   to their source components regardless of direction.

   donutPctLabelSizePx — controls the px font-size of percentage labels
   drawn inside donut slices. Not exposed in the UI.
   Valid range: 8–24. Default: 18.
═══════════════════════════════════════════════════════════════════════ */
const CFG = {
  donutCutout:         '65%',
  donutBorderW:        2,
  donutBorderC:        '#000000',
  donutHoverOff:       14,
  donutClockwise:      true,
  donutStartAngle:     0,
  zGoodMin:            3,
  zMidMin:             2,
  donutPctLabelSizePx:  18,   /* desktop/tablet slice % label size (px) */
  tooltipBodyFontSizePx: 12,   /* base donut tooltip body font size (px) */
  tooltipTitleFontSizePx: 12,  /* base donut tooltip title font size (px) */
};

/* ═══════════════════════════════════════════════════════════════════════
   MOBILE-ONLY TYPOGRAPHY & SPACING
   Applied only when isMobileLayout() is true.
═══════════════════════════════════════════════════════════════════════ */
const MOBILE_VIEW = {
  tableWidthPercent:      95,                        /* mobile/portrait sources+outgroups block width (%) */
  targetHeadingFontSize:  'clamp(55px, 8.5vw, 80px)', /* Target: ... heading */
  statFontSize:           'clamp(30px, 5vw, 50px)',   /* χ² / p stats line */
  sourcesHeaderFontSize:  '28px',                     /* SOURCES header */
  outgroupsHeaderFontSize:'28px',                     /* OUTGROUPS header */
  outgroupsListFontSize:  '28px',                     /* outgroups list text */
  sourcesNameFontSize:    '38px',                     /* source population name */
  sourcesCoeffFontSize:   '35px',                     /* coeff ± SE line */
  sourcesZFontSize:       '32px',                     /* (Z: ...) */
  sourcesNameFontWeight:  600,
  sourcesNameFontStyle:   'normal',
  sourcesCoeffFontWeight: 450,
  sourcesCoeffFontStyle:  'normal',
  sourcesZFontWeight:     430,
  sourcesZFontStyle:      'normal',
  equalSourceRowHeights:  true,                       /* mobile: keep source rows equal height */
  sourcesRowPadTopPx:     10,                         /* mobile row padding top */
  sourcesRowPadBottomPx:  10,                         /* mobile row padding bottom */
  sourcesOutgroupsGap:    '28px',                     /* vertical gap between sources + outgroups tables */
  outgroupsBottomInsetPx: 0,                          /* mobile: minimum gap from card bottom edge */
  outgroupsAutoFillGap:   true,                       /* mobile: auto-fill space between sources/outgroups */
  sourcesTableBottomPadPx: 12,                        /* extra bottom breathing room in sources table */
  sourcesLastRowExtraBottomPadPx: 8,                  /* extra bottom pad only for last source row */
  sourcesSwatchInsetPx:   2,                          /* vertical inset so swatch never touches row edges */
  sourcesSwatchBarWidthPx: 18,                        /* mobile elongated swatch width */
  sourcesSwatchBarRadiusPx: 3,                        /* mobile elongated swatch corner radius */
  sourcesSwatchBarBorderWidthPx: 2,                   /* mobile elongated swatch border width */
  sourcesSwatchBarBorderColor: '#000000',             /* mobile elongated swatch border color */
  verdictFontSize:        'clamp(24px, 3.8vw, 34px)', /* PASS/FAIL badge text */
  verdictPaddingV:        5,                         /* PASS/FAIL badge vertical padding (px) */
  verdictPaddingH:        5,                         /* PASS/FAIL badge horizontal padding (px) */
  verdictAnchorX:         'card-right',               /* 'card-right' or 'donut-right' */
  verdictOffsetX:         -8,                          /* horizontal shift from anchor (+right / -left) */
  verdictOffsetY:         8,                          /* from donut top-right, px (+down / -up) */
  verdictRightInsetPx:    25,                         /* right inset when verdictAnchorX = 'card-right' */
  donutPctLabelSizePx:    30,                         /* mobile slice % label size (px) */
  /* FIX: reduced from 3 to 2.0 — tooltips at 3× base (36px) overflowed the card on mobile */
  tooltipSizeScale:       2.0,                        /* mobile donut tooltip scale */
  donutSizeScale:         0.94,                       /* base mobile donut scale */
  donutShiftYPx:          0,                          /* base mobile donut vertical shift */
  /* Adaptive anti-congestion rule for mobile:
     stage 1 → decrease space above/below donut
     stage 2 → decrease donut size
     stage 3 → decrease sources table font sizes + row height
     (without truncating data). */
  adaptiveEnabled:              true,
  adaptiveSourceCountStart:     3,
  adaptiveSourceCountMax:       6,
  adaptiveNameLenStart:         18,
  adaptiveNameLenMax:           34,
  adaptiveStage1SpaceEnd:       0.45,                 /* end of stage 1 (space compression) */
  adaptiveStage2DonutEnd:       0.80,                 /* end of stage 2 (donut shrink) */
  adaptiveExtraDonutShrinkMax:  0.16,                 /* extra shrink on top of donutSizeScale */
  adaptiveDonutShiftUpMaxPx:    12,                   /* stage 1: reduce top gap */
  adaptivePanelTopShiftUpMaxPx: 16,                   /* stage 1: reduce bottom gap (table moves up) */
  adaptiveGapReduceMaxPx:       10,                   /* reduce sources/outgroups gap */
  adaptiveFontScaleMaxDrop:     0.28,                 /* max font reduction in stage 3 */
  adaptiveRowPadScaleMaxDrop:   0.40,                 /* max row/header padding reduction in stage 3 */
  /* Source-count pressure (applies uniformly to all rows, prevents last-row clipping) */
  adaptiveCountStart:           3,
  adaptiveCountMax:             6,
  adaptiveCountPanelTopShiftMaxPx: 12,
  adaptiveCountGapReduceMaxPx:  6,
  adaptiveCountDonutShrinkMax:  0.06,
  adaptiveCountFontDropMax:     0.12,
  adaptiveCountRowPadDropMax:   0.16,
};

const SIGNATURE = {
  enabled:       true,
  text:          'ad99',
  fontFamily:    'Roboto, sans-serif',
  fontSize:      '12px',   /* slightly more prominent default */
  fontWeight:    800,
  fontStyle:     'normal',
  letterSpacing: '0',
  lineHeight:    '1',
  color:         '',      /* empty = use themed watermark color */
  opacity:       0.88,
  rightInsetPx:  9,       /* horizontal position from right edge */
  bottomInsetPx: 0,       /* vertical position from bottom edge */
  zIndex:        6,
};

/* Numeric-only typography (coeff/SE/Z + donut % labels) */
const NUMERIC_TYPO = {
  desktop: {
    table: 'Roboto, sans-serif',                 /* default/standard/wide numerics */
    donutPct: 'Roboto, sans-serif',              /* default/standard/wide donut % */
  },
  square: {
    table: 'Roboto, sans-serif',                 /* default/standard/wide numerics */
    donutPct: 'Roboto, sans-serif',              /* default/standard/wide donut % */
  },
  mobile: {
    table: 'Fira Mono, DM Mono, monospace',     /* mobile numerics */
    donutPct: 'Fira Mono, DM Mono, monospace',  /* mobile donut % */
  },
};

/* ═══════════════════════════════════════════════════════════════════════
   SQUARE-VIEW TYPOGRAPHY & WIDTH
   Applied only when activeLayout === 'square'.
═══════════════════════════════════════════════════════════════════════ */
const SQUARE_VIEW = {
  tableWidthPercent:      70,                         /* square sources-table minimum width (%) */
  tableWidthDynamic:      true,                       /* auto-expand square sources-table when content overflows */
  tableWidthBufferRatio:  1.2,                        /* expand to 20% more than required width */
  preWrapWidthMaxPercent: 90,                         /* square: max width before allowing name/data row wrapping */
  tableWidthMaxPercent:   100,                        /* cap square sources-table width (%) */
  dynamicColumns:         true,                       /* square: let name/data columns auto-size to content */
  targetHeadingFontSize:  'clamp(44px, 5.4vw, 68px)', /* Target: ... heading */
  statFontSize:           'clamp(22px, 2.4vw, 36px)', /* χ² / p stats line */
  targetStatsGapPx:       16,                         /* vertical gap between target and stats in square */
  donutPctLabelSizePx:    20,                         /* donut % label size in square view */
  sourcesHeaderFontSize:  '18px',                     /* SOURCES header */
  outgroupsHeaderFontSize:'18px',                     /* OUTGROUPS header */
  sourcesNameFontFamily:  'Roboto, sans-serif',       /* source name font family */
  sourcesNameFontSize:    '25px',                     /* source name */
  sourcesNameFontWeight:  600,
  sourcesNameFontStyle:   'normal',
  sourcesCoeffFontFamily: NUMERIC_TYPO.square.table,  /* coeff ± SE font family */
  sourcesCoeffFontSize:   '25px',                     /* coeff ± SE */
  sourcesCoeffFontWeight: 500,
  sourcesCoeffFontStyle:  'normal',
  sourcesZFontFamily:     NUMERIC_TYPO.square.table,  /* Z text font family */
  sourcesZFontSize:       '23px',                     /* Z text */
  sourcesZFontWeight:     500,
  sourcesZFontStyle:      'normal',
  outgroupsListFontFamily:'Roboto, sans-serif',       /* square outgroups footer font family */
  outgroupsListFontSize:  '18px',                     /* outgroups list text */
  outgroupsListFontWeight:500,                        /* square outgroups footer font weight */
  verdictFontSize:        'clamp(16px, 1.9vw, 24px)', /* square PASS/FAIL badge text */
  verdictPaddingV:        6,                          /* square verdict vertical padding */
  verdictPaddingH:        8,                          /* square verdict horizontal padding */
  tableLayoutMode:        'auto',                     /* safer for narrowed square table width */
  dataColWidth:           '46%',                      /* coeff ± SE (Z) col width when dynamicColumns=false */
  swatchColWidthPx:       40,                         /* square swatch col width */
  swatchCellWidthPx:      44,                         /* square swatch cell width */
  swatchPadLeftPx:        10,                         /* square swatch cell left pad */
  swatchPadRightPx:       5,                          /* square swatch cell right pad */
  swatchWidth:            '29px',                     /* square swatch width */
  swatchHeight:           '32px',                     /* square swatch height */
  swatchRadius:           '3px',                      /* square swatch border radius */
  swatchBorder:           '2px solid #000',           /* square swatch border (syncs with donut edge) */
  donutSizeScale:         0.76,                       /* square donut size multiplier (adds vertical breathing room) */
  donutShiftYPx:          -10,                        /* square donut vertical shift (+down / -up) */
  spacingScale:           1.0,                        /* global spacing multiplier for square view */
  infoGapMinPx:           6,                          /* sources/outgroups block gap (min) */
  infoGapMaxPx:           12,                         /* sources/outgroups block gap (max) */
  tableHeaderPadYMinPx:   4,                          /* table header vertical padding (min) */
  tableHeaderPadYMaxPx:   8,                          /* table header vertical padding (max) */
  tableCellPadYMinPx:     4,                          /* table row vertical padding (min) */
  tableCellPadYMaxPx:     7,                          /* table row vertical padding (max) */
  tableCellPadXMinPx:     10,                         /* table row horizontal padding (min) */
  tableCellPadXMaxPx:     16,                         /* table row horizontal padding (max) */
  /* Adaptive anti-congestion rule:
     if many/long sources make square layout dense, shrink donut more and
     compress vertical gaps around donut instead of truncating data display. */
  adaptiveEnabled:              true,
  adaptiveSourceCountStart:     3,
  adaptiveSourceCountMax:       6,
  adaptiveNameLenStart:         18,
  adaptiveNameLenMax:           34,
  adaptiveDataLenStart:         24,                   /* start congestion from long coeff±SE(Z) strings */
  adaptiveDataLenMax:           42,                   /* max congestion from coeff±SE(Z) string length */
  adaptiveOutgroupsLenStart:    90,                   /* start congestion from long outgroups footer */
  adaptiveOutgroupsLenMax:      220,                  /* max congestion from outgroups footer length */
  adaptiveFontScaleMaxDrop:     0.24,                 /* max square table font shrink when congested */
  adaptiveExtraDonutShrinkMax:  0.18,                 /* extra shrink on top of donutSizeScale */
  adaptiveDonutShiftUpMaxPx:    48,                   /* move donut up to reduce top gap */
  adaptivePanelTopShiftUpMaxPx: 56,                   /* move sources panel up to reduce bottom gap */
  adaptiveInfoGapReduceMaxPx:   12,                   /* reduce sources/outgroups gap under congestion */
  fitZOnlyMaxDropPx:            2,                    /* stage 1: max Z-score font drop (px) */
  fitAllMaxDropPx:              2,                    /* stage 2: max all table text drop (px) */
  fitFinalAllMaxDropPx:         2,                    /* stage 4: max all table text drop (px) */
};

/* ═══════════════════════════════════════════════════════════════════════
   SWATCH
═══════════════════════════════════════════════════════════════════════ */
const SWATCH = { width: '29px', height: '23px', radius: '3px', border: '1.0px solid #000' };

/* ═══════════════════════════════════════════════════════════════════════
   TYPOGRAPHY (colours mutated by applyTheme)
═══════════════════════════════════════════════════════════════════════ */
const TYPOGRAPHY = {
  target: {
    font: 'Roboto, sans-serif', fontSize: 'clamp(26px, 4vw, 60px)',
    fontWeight: 900, fontStyle: 'normal', color: '#0a0a0a',
    letterSpacing: '-0.02em', lineHeight: '1.05', align: 'center',
  },
  stat: {
    font: 'DM Mono, monospace', fontSize: 'clamp(11px, 1.6vw, 28px)',
    fontWeight: 400, fontStyle: 'normal', color: '#555555',
    letterSpacing: '0.01em', lineHeight: '1.3', align: 'center', marginTop: '2px',
  },
  headerPadding: { top: '10px', sides: '24px', bottom: '0px' },
  verdict: {
    font: 'Roboto, sans-serif', fontSize: 'clamp(8px, 1.5vw, 18px)',
    fontWeight: 800, fontStyle: 'normal', letterSpacing: '0.14em',
  },
  sourcesHeader: {
    font: 'Roboto, sans-serif', fontSize: '12px', fontWeight: 600,
    fontStyle: 'normal', color: '#6b7280', letterSpacing: '0.1em',
    lineHeight: '1.4', align: 'center', text: 'Coeff \u00B1 SE  (Z-score)',
    textTransform: 'uppercase',
  },
  sourcesName: {
    font: 'Roboto, sans-serif', fontSize: '17px', fontWeight: 500,
    fontStyle: 'normal', color: '#111111', letterSpacing: '0',
    lineHeight: '1.35', align: 'left',
  },
  sourcesCoeff: {
    font: NUMERIC_TYPO.desktop.table, fontSize: '17px', fontWeight: 500,
    fontStyle: 'normal', color: '#111111', letterSpacing: '0', align: 'left',
  },
  sourcesZ: {
    font: NUMERIC_TYPO.desktop.table, fontSize: '15px', fontWeight: 500,
    fontStyle: 'normal', letterSpacing: '0',
    zPrefix: 'Z:\u2009',
    zSepPx:  8,
  },
  sourcesColon: { colonText: ': ', colonFont: 'Roboto, sans-serif', colonColor: '#111111' },
  sourcesRowOverrides: [],
  outgroupsHeader: {
    font: 'Roboto, sans-serif', fontSize: '12px', fontWeight: 600,
    fontStyle: 'normal', color: '#6b7280', letterSpacing: '0.1em',
    lineHeight: '1.4', align: 'center', text: 'Right (Outgroups)',
    textTransform: 'uppercase',
  },
  outgroupsCell: {
    font: 'Roboto, sans-serif', fontSize: '15px', fontWeight: 500,
    fontStyle: 'normal', color: '#6b7280', letterSpacing: '0', lineHeight: '1.6', align: 'left',
  },
  watermark: {
    font: 'Roboto, sans-serif', fontSize: '7px', fontWeight: 500,
    fontStyle: 'normal', color: '#c0cad6', letterSpacing: '0',
  },
};

/* ═══════════════════════════════════════════════════════════════════════
   THEME SYSTEM
   Note: Z_COLORS variants are included so applyTheme() can update them
   for better contrast on dark cards (light greens/yellows/reds).
═══════════════════════════════════════════════════════════════════════ */
const THEMES = {
  light: {
    cardBg: '#ffffff', donutBorderC: '#000000',
    target:          { color: '#0a0a0a' },
    stat:            { color: '#555555' },
    sourcesName:     { color: '#111111' },
    sourcesCoeff:    { color: '#111111' },
    sourcesColon:    { colonColor: '#111111' },
    sourcesHeader:   { color: '#6b7280' },
    outgroupsHeader: { color: '#6b7280' },
    outgroupsCell:   { color: '#6b7280' },
    watermark:       { color: '#c0cad6' },
    table: {
      boxBorderColor: '#d1d5db', headerBg: '#f3f4f6',
      headerBorderColor: '#d1d5db', rowBorderColor: '#e5e7eb',
    },
    verdict: {
      passBg: '#f3fefd', passText: '#3a9063',
      weakBg: '#fefce8', weakText: '#ca8a04',
      failBg: '#FFFAFA', failText: '#dc2626',
    },
    /* Z-score tier colours for light cards — standard saturated tones */
    zColors: { zGood: '#16a34a', zMid: '#ca8a04', zBad: '#dc2626' },
  },
  dark: {
    cardBg: '#1a1a1a', donutBorderC: '#2a2a2a',
    target:          { color: '#f0f0f0' },
    stat:            { color: '#9ca3af' },
    sourcesName:     { color: '#e5e7eb' },
    sourcesCoeff:    { color: '#e5e7eb' },
    sourcesColon:    { colonColor: '#e5e7eb' },
    sourcesHeader:   { color: '#9ca3af' },
    outgroupsHeader: { color: '#9ca3af' },
    outgroupsCell:   { color: '#9ca3af' },
    watermark:       { color: '#4b5563' },
    table: {
      boxBorderColor: '#374151', headerBg: '#262626',
      headerBorderColor: '#374151', rowBorderColor: '#2d2d2d',
    },
    verdict: {
      passBg: '#0a2e20', passText: '#4ade80',
      weakBg: '#2a2000', weakText: '#fbbf24',
      failBg: '#2e1010', failText: '#f87171',
    },
    /* Z-score tier colours for dark cards — lighter/higher-contrast variants */
    zColors: { zGood: '#4ade80', zMid: '#fbbf24', zBad: '#f87171' },
  },
};

let currentTheme = 'light';

function borderStyleFrom(borderStr) {
  const b = (borderStr || '').trim();
  const m = b.match(/^\d*\.?\d+(?:px|em|rem|%)?\s+([a-zA-Z]+)/);
  return m ? m[1] : 'solid';
}

function syncSwatchBordersToDonutEdges() {
  const donutW = Math.max(0, Number(CFG.donutBorderW) || 2);
  const donutC = CFG.donutBorderC || '#000000';
  SWATCH.border = `${donutW}px ${borderStyleFrom(SWATCH.border)} ${donutC}`;
  SQUARE_VIEW.swatchBorder = `${donutW}px ${borderStyleFrom(SQUARE_VIEW.swatchBorder)} ${donutC}`;
  MOBILE_VIEW.sourcesSwatchBarBorderWidthPx = donutW;
  MOBILE_VIEW.sourcesSwatchBarBorderColor = donutC;
}

function applyTheme(mode) {
  currentTheme = mode;
  const t = THEMES[mode];
  CARD.bgColor     = t.cardBg;
  CFG.donutBorderC = t.donutBorderC;
  syncSwatchBordersToDonutEdges();
  Object.assign(TYPOGRAPHY.target,          t.target);
  Object.assign(TYPOGRAPHY.stat,            t.stat);
  Object.assign(TYPOGRAPHY.sourcesName,     t.sourcesName);
  Object.assign(TYPOGRAPHY.sourcesCoeff,    t.sourcesCoeff);
  Object.assign(TYPOGRAPHY.sourcesColon,    t.sourcesColon);
  Object.assign(TYPOGRAPHY.sourcesHeader,   t.sourcesHeader);
  Object.assign(TYPOGRAPHY.outgroupsHeader, t.outgroupsHeader);
  Object.assign(TYPOGRAPHY.outgroupsCell,   t.outgroupsCell);
  Object.assign(TYPOGRAPHY.watermark,       t.watermark);
  TABLE_STYLE.boxBorderColor    = t.table.boxBorderColor;
  TABLE_STYLE.headerBg          = t.table.headerBg;
  TABLE_STYLE.headerBorderColor = t.table.headerBorderColor;
  TABLE_STYLE.rowBorderColor    = t.table.rowBorderColor;
  VERDICT_POS.passBg   = t.verdict.passBg;   VERDICT_POS.passText = t.verdict.passText;
  VERDICT_POS.weakBg   = t.verdict.weakBg;   VERDICT_POS.weakText = t.verdict.weakText;
  VERDICT_POS.failBg   = t.verdict.failBg;   VERDICT_POS.failText = t.verdict.failText;
  /* FIX: mutate Z_COLORS so Z-score labels always contrast against the card background */
  if (t.zColors) Object.assign(Z_COLORS, t.zColors);
}

function onThemeChange(val) {
  applyTheme(val);
  savePref('qpviz_theme', val);
  if (document.getElementById('card').style.display !== 'none') parseAndDraw();
}

/* ═══════════════════════════════════════════════════════════════════════
   COLOR PALETTES  (indices 0–18)
═══════════════════════════════════════════════════════════════════════ */
const colorPalettes = [
  ['#4c72b0','#55a868','#c44e52','#8172b2','#ccb974','#64b5cd'],
  ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628'],
  ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b'],
  ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#a6761d'],
  ['#c8943a','#2a7f7f','#c0533a','#4a5fa0','#6b8c42','#a05050'],
  ['#3b82c4','#e8622c','#2da87a','#9b59b6','#e6a817','#708090'],
  ['#111111','#2f2f2f','#555555','#7a7a7a','#a0a0a0','#cfcfcf'],
  ['#1a1a1a','#3a3a3a','#5a5a5a','#7a7a7a','#9a9a9a','#bababa'],
  ['#2b2b2b','#4b4b4b','#6b6b6b','#8b8b8b','#ababab','#d0d0d0'],
  ['#08306b','#08519c','#2171b5','#4292c6','#6baed6','#9ecae1'],
  ['#00441b','#006d2c','#238b45','#41ab5d','#74c476','#a1d99b'],
  ['#0072b2','#e69f00','#009e73','#d55e00','#cc79a7','#56b4e9'],
  ['#4477aa','#ee6677','#228833','#ccbb44','#66ccee','#aa3377'],
  ['#b5572b','#4878a0','#7ab080','#d4a44c','#6f5094','#c88c8c'],
  ['#7ba7c7','#e8a97e','#8abb9e','#d4879b','#b3a6d0','#c4b882'],
  ['#e41a1c','#1f78b4','#33a02c','#ff7f00','#6a3d9a','#b15928'],
  ['#60a5fa','#34d399','#f87171','#fbbf24','#a78bfa','#fb923c'],
  ['#93c5fd','#6ee7b7','#fca5a5','#fde68a','#c4b5fd','#fdba74'],
  ['#38bdf8','#818cf8','#34d399','#fb7185','#fbbf24','#a3e635'],
];

/* ═══════════════════════════════════════════════════════════════════════
   STATE
   lastColors       — colors in current chart order (may be reversed)
   originalColors   — colors in original source order (never reversed)
   chartIsReversed  — tracks whether chart data is currently reversed
   lastSourceCount  — number of sources in the current render
═══════════════════════════════════════════════════════════════════════ */
let chartObj        = null;
let showLabels      = false;
let lastColors      = [];
let originalColors  = [];
let chartIsReversed = false;
let lastSourceCount = 0;
let currentParsedData = null;
let lastRenderedMobile = null;
let squareFitPressure = 0; /* 0..1 runtime pressure from measured square-table overflow */

/* ═══════════════════════════════════════════════════════════════════════
   PERSISTENCE
═══════════════════════════════════════════════════════════════════════ */
function savePref(k, v) { try { localStorage.setItem(k, String(v)); } catch(e) {} }
function loadPref(k)     { try { return localStorage.getItem(k); }    catch(e) { return null; } }

function loadPrefs() {
  const cutout = loadPref('qpviz_cutout');
  if (cutout) {
    const v = parseInt(cutout);
    if (v >= 20 && v <= 90) {
      document.getElementById('cutoutInput').value = v;
      CFG.donutCutout = v + '%';
    }
  }
  const theme = loadPref('qpviz_theme');
  if (theme === 'dark' || theme === 'light') {
    document.getElementById('themeSelect').value = theme;
    applyTheme(theme);
  }
  const palette = loadPref('qpviz_palette');
  if (palette !== null) {
    const sel = document.getElementById('paletteSelect');
    if (sel.querySelector(`option[value="${palette}"]`)) sel.value = palette;
  }
  const ratio = loadPref('qpviz_ratio');
  if (ratio) {
    const sel = document.getElementById('ratioSelect');
    const opt = sel.querySelector(`option[value="${ratio}"]`);
    if (opt) {
      sel.value        = ratio;
      activeLayout     = ratio;
      CARD.aspectRatio = opt.dataset.ar;
    }
  }
  if (loadPref('qpviz_labels') === 'true') {
    showLabels = true;
    document.getElementById('labelToggle').classList.add('active');
  }
  if (loadPref('qpviz_cw') === 'false') {
    CFG.donutClockwise = false;
    const btn = document.getElementById('cwToggle');
    btn.textContent = '↺ CCW';
    btn.classList.add('active');
  }
  syncSwatchBordersToDonutEdges();
}

/* ═══════════════════════════════════════════════════════════════════════
   MOBILE LAYOUT DETECTION
   ── FIX 1 ──
   Returns true when:
   - The actual screen width is ≤ 640 px (real mobile device), OR
   - The user has selected the 'portrait' ratio on any screen size.
     This lets desktop users intentionally preview the mobile layout.
═══════════════════════════════════════════════════════════════════════ */
function isMobileLayout() {
  return activeLayout === 'portrait' || (window.innerWidth <= 640 && activeLayout !== 'square');
}

function isSquareLayout() {
  return activeLayout === 'square';
}

function numericTableFontForLayout() {
  if (isMobileLayout()) return NUMERIC_TYPO.mobile.table;
  if (isSquareLayout()) return NUMERIC_TYPO.square.table;
  return NUMERIC_TYPO.desktop.table;
}

function numericDonutPctFontForLayout() {
  if (isMobileLayout()) return NUMERIC_TYPO.mobile.donutPct;
  if (isSquareLayout()) return NUMERIC_TYPO.square.donutPct;
  return NUMERIC_TYPO.desktop.donutPct;
}

function squareSpace(minPx, maxPx) {
  const cardEl = document.getElementById('card');
  const w = cardEl && cardEl.offsetWidth ? cardEl.offsetWidth : 900;
  const t = Math.max(0, Math.min(1, (w - 520) / (1040 - 520)));
  const base = minPx + (maxPx - minPx) * t;
  return Math.round(base * (SQUARE_VIEW.spacingScale || 1));
}

function getMobileCongestionFactor() {
  if (!isMobileLayout() || !MOBILE_VIEW.adaptiveEnabled || !currentParsedData) return 0;
  const srcs = currentParsedData.sources || [];
  if (!srcs.length) return 0;
  const n = srcs.length;
  const maxLen = Math.max(...srcs.map(s => (s || '').length));
  const nF = (n - MOBILE_VIEW.adaptiveSourceCountStart) /
             Math.max(1, (MOBILE_VIEW.adaptiveSourceCountMax - MOBILE_VIEW.adaptiveSourceCountStart));
  const lF = (maxLen - MOBILE_VIEW.adaptiveNameLenStart) /
             Math.max(1, (MOBILE_VIEW.adaptiveNameLenMax - MOBILE_VIEW.adaptiveNameLenStart));
  return Math.max(0, Math.min(1, Math.max(nF, lF)));
}

function getMobileAdaptiveProfile() {
  const f = getMobileCongestionFactor();
  const srcs = currentParsedData && currentParsedData.sources ? currentParsedData.sources : [];
  const countT = Math.max(
    0,
    Math.min(1, (srcs.length - MOBILE_VIEW.adaptiveCountStart) /
      Math.max(1, (MOBILE_VIEW.adaptiveCountMax - MOBILE_VIEW.adaptiveCountStart)))
  );
  const s1End = Math.max(0.05, Math.min(0.9, MOBILE_VIEW.adaptiveStage1SpaceEnd));
  const s2End = Math.max(s1End + 0.05, Math.min(0.98, MOBILE_VIEW.adaptiveStage2DonutEnd));
  const stage1 = Math.min(1, f / s1End);
  const stage2 = f <= s1End ? 0 : Math.min(1, (f - s1End) / (s2End - s1End));
  const stage3 = f <= s2End ? 0 : Math.min(1, (f - s2End) / (1 - s2End));
  const panelTopShiftUp =
    (stage1 * MOBILE_VIEW.adaptivePanelTopShiftUpMaxPx) +
    (countT * MOBILE_VIEW.adaptiveCountPanelTopShiftMaxPx);
  const gapReduce =
    (stage1 * MOBILE_VIEW.adaptiveGapReduceMaxPx) +
    (countT * MOBILE_VIEW.adaptiveCountGapReduceMaxPx);
  const donutShrink =
    (stage2 * MOBILE_VIEW.adaptiveExtraDonutShrinkMax) +
    (countT * MOBILE_VIEW.adaptiveCountDonutShrinkMax);
  const fontScale =
    (1 - (stage3 * MOBILE_VIEW.adaptiveFontScaleMaxDrop)) *
    (1 - (countT * MOBILE_VIEW.adaptiveCountFontDropMax));
  const rowPadScale =
    (1 - (stage3 * MOBILE_VIEW.adaptiveRowPadScaleMaxDrop)) *
    (1 - (countT * MOBILE_VIEW.adaptiveCountRowPadDropMax));
  return {
    congestion: f,
    countPressure: countT,
    donutShiftUp: stage1 * MOBILE_VIEW.adaptiveDonutShiftUpMaxPx,
    panelTopShiftUp,
    gapReduce,
    donutShrink,
    fontScale,
    rowPadScale,
  };
}

function getSquareCongestionFactor() {
  if (!isSquareLayout() || !SQUARE_VIEW.adaptiveEnabled || !currentParsedData) return 0;
  const srcs = currentParsedData.sources || [];
  if (!srcs.length) return 0;
  const n = srcs.length;
  const maxLen = Math.max(...srcs.map(s => (s || '').length));
  const ws = currentParsedData.weights || [];
  const ss = currentParsedData.sesPct || [];
  const zs = currentParsedData.zScores || [];
  const outLen = ((currentParsedData.outgroups || '').length);
  const dataLens = srcs.map((_, i) =>
    `${(Number(ws[i]) || 0).toFixed(1)}% ± ${(Number(ss[i]) || 0).toFixed(2)}% (Z: ${(Number(zs[i]) || 0).toFixed(2)})`.length
  );
  const maxDataLen = dataLens.length ? Math.max(...dataLens) : 0;
  const nF = (n - SQUARE_VIEW.adaptiveSourceCountStart) /
             Math.max(1, (SQUARE_VIEW.adaptiveSourceCountMax - SQUARE_VIEW.adaptiveSourceCountStart));
  const lF = (maxLen - SQUARE_VIEW.adaptiveNameLenStart) /
             Math.max(1, (SQUARE_VIEW.adaptiveNameLenMax - SQUARE_VIEW.adaptiveNameLenStart));
  const dF = (maxDataLen - (SQUARE_VIEW.adaptiveDataLenStart || 24)) /
             Math.max(1, ((SQUARE_VIEW.adaptiveDataLenMax || 42) - (SQUARE_VIEW.adaptiveDataLenStart || 24)));
  const oF = (outLen - (SQUARE_VIEW.adaptiveOutgroupsLenStart || 90)) /
             Math.max(1, ((SQUARE_VIEW.adaptiveOutgroupsLenMax || 220) - (SQUARE_VIEW.adaptiveOutgroupsLenStart || 90)));
  return Math.max(0, Math.min(1, Math.max(nF, lF, dF, oF)));
}

function resetViewDynamicSizing() {
  squareFitPressure = 0;
  const sourcesBox = document.getElementById('sourcesBox');
  const outgroupsBox = document.getElementById('outgroupsBox');
  const outgroupsFoot = document.getElementById('outgroupsFoot');
  if (sourcesBox) {
    sourcesBox.style.width = '';
    sourcesBox.style.marginLeft = '';
    sourcesBox.style.marginRight = '';
    sourcesBox.style.flexShrink = '';
    sourcesBox.style.minHeight = '';
  }
  if (outgroupsBox) {
    outgroupsBox.style.width = '';
    outgroupsBox.style.marginLeft = '';
    outgroupsBox.style.marginRight = '';
    outgroupsBox.style.flexShrink = '';
    outgroupsBox.style.marginTop = '';
    outgroupsBox.style.marginBottom = '';
  }
  if (outgroupsFoot) {
    outgroupsFoot.style.width = '';
    outgroupsFoot.style.marginLeft = '';
    outgroupsFoot.style.marginRight = '';
    outgroupsFoot.style.flexShrink = '';
  }
  const els = Array.from(document.querySelectorAll(
    '#sourcesBox .pop-name, #sourcesBox .coeff-text, #sourcesBox .z-text, #sourcesHead th, #outgroupsFoot'
  ));
  els.forEach((el) => {
    el.style.fontSize = '';
    el.style.whiteSpace = '';
    el.style.overflowWrap = '';
    el.style.wordBreak = '';
    if (el.dataset && el.dataset.baseFsSq) delete el.dataset.baseFsSq;
  });
}

/* ═══════════════════════════════════════════════════════════════════════
   CONTROL HANDLERS
═══════════════════════════════════════════════════════════════════════ */
function onRatioChange(val) {
  const opt = document.querySelector(`#ratioSelect option[value="${val}"]`);
  if (!opt) return;
  activeLayout     = val;
  CARD.aspectRatio = opt.dataset.ar;
  resetViewDynamicSizing();
  savePref('qpviz_ratio', val);
  /* Full re-render on every view change so widths/fonts don't carry over. */
  parseAndDraw();
}

/* FIX: clamp the displayed value in the input field so out-of-range numbers
   don't visually persist after the handler returns early. */
function onCutoutChange(val) {
  const v = parseInt(val);
  if (isNaN(v)) return;
  const clamped = Math.min(90, Math.max(20, v));
  document.getElementById('cutoutInput').value = clamped;
  CFG.donutCutout = clamped + '%';
  savePref('qpviz_cutout', clamped);
  if (chartObj) { chartObj.options.cutout = CFG.donutCutout; chartObj.update(); }
}

/* ═══════════════════════════════════════════════════════════════════════
   DONUT DIRECTION TOGGLE
   ── FIX 2 ──
   True directional flip via data-array reversal.

   How it works:
   - The circumference is always +360 (full circle, clockwise draw order).
   - CW  mode: segments fed in original source order → drawn CW  as [1,2,3,…]
   - CCW mode: segments fed in REVERSED order        → drawn CW  as […,3,2,1]
     which makes them appear counter-clockwise from the same start angle.

   Colors stay bound to their source component:
     source[0] always has originalColors[0], regardless of direction.

   The table / info panel always shows sources in original order.
═══════════════════════════════════════════════════════════════════════ */
function toggleClockwise() {
  CFG.donutClockwise = !CFG.donutClockwise;
  savePref('qpviz_cw', CFG.donutClockwise);
  const btn = document.getElementById('cwToggle');
  btn.textContent = CFG.donutClockwise ? '↻ CW' : '↺ CCW';
  btn.classList.toggle('active', !CFG.donutClockwise);

  if (chartObj) {
    /* Rebuild reversed arrays to avoid shared-reference double-reverse bugs */
    const ds = chartObj.data.datasets[0];
    const nextData   = [...ds.data].reverse();
    const nextLabels = [...chartObj.data.labels].reverse();
    const nextColors = [...ds.backgroundColor].reverse();

    ds.data                 = nextData;
    ds.backgroundColor      = nextColors;
    ds.hoverBackgroundColor = [...nextColors];
    chartObj.data.labels    = nextLabels;

    /* Sync lastColors to the new order for datalabels color callback */
    lastColors      = [...nextColors];
    chartIsReversed = !CFG.donutClockwise;

    /* Refresh datalabels color callback with updated order */
    chartObj.options.plugins.datalabels.color =
      (ctx) => labelColorFor(lastColors[ctx.dataIndex] || '#888888');

    chartObj.update();
  }
}

function toggleLabels() {
  showLabels = !showLabels;
  savePref('qpviz_labels', showLabels);
  document.getElementById('labelToggle').classList.toggle('active', showLabels);
  if (chartObj) {
    chartObj.options.plugins.datalabels.display =
      (ctx) => showLabels && ctx.dataset.data[ctx.dataIndex] > 5;
    chartObj.update();
  }
}

/* ═══════════════════════════════════════════════════════════════════════
   FILE UPLOAD & EXAMPLE
═══════════════════════════════════════════════════════════════════════ */
function handleFileUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload  = e => {
    document.getElementById('qpadmText').value = e.target.result;
    setFormatBadge('', '');
    parseAndDraw();
  };
  reader.onerror = () => showBadgeError('File read error');
  reader.readAsText(file);
  event.target.value = '';
}

/* FIX: confirm before silently replacing user's existing input */
function loadExample() {
  const ta = document.getElementById('qpadmText');
  if (ta.value.trim() && !confirm('Replace current input with the example?')) return;
  ta.value =
`Target: Hungary_MBA
Weights:
Yamnaya_Samara - 42.3% SE: 4.12% Z: 10.27
Anatolia_N - 38.1% SE: 3.87% Z: 9.84
WHG - 19.6% SE: 3.45% Z: 5.68
P value: 0.243
chisq: 2.81
Rights: Mbuti, Yoruba, Han, Papuan, Onge`;
  parseAndDraw();
}

/* ═══════════════════════════════════════════════════════════════════════
   LAYOUT ENGINE
═══════════════════════════════════════════════════════════════════════ */
function applyLayout() {
  const cardEl = document.getElementById('card');
  const wrap   = document.getElementById('donutWrap');
  const info   = document.getElementById('infoCol');
  if (cardEl.style.display === 'none') return;

  const cW = cardEl.offsetWidth;
  const cH = cardEl.offsetHeight;
  const p  = LAYOUT_PROFILES[activeLayout] || LAYOUT_PROFILES['landscape-wide'];

  let d  = (p.donutDiameter / 100) * cW;
  const cx = (p.donutCenterX  / 100) * cW;
  let cy = (p.donutCenterY  / 100) * cH;
  const mobile = isMobileLayout();
  const mobileAdaptive = getMobileAdaptiveProfile();
  const squareCongestion = isSquareLayout() ? squareFitPressure : getSquareCongestionFactor();
  if (isSquareLayout()) {
    const extraShrink = squareCongestion * SQUARE_VIEW.adaptiveExtraDonutShrinkMax;
    d *= Math.max(0.5, SQUARE_VIEW.donutSizeScale - extraShrink);
    cy += SQUARE_VIEW.donutShiftYPx - (squareCongestion * SQUARE_VIEW.adaptiveDonutShiftUpMaxPx);
  } else if (mobile) {
    d *= Math.max(0.45, MOBILE_VIEW.donutSizeScale - mobileAdaptive.donutShrink);
    cy += MOBILE_VIEW.donutShiftYPx - mobileAdaptive.donutShiftUp;
  }

  info.style.left   = ((p.panelLeft   / 100) * cW) + 'px';
  const infoTopBase = ((p.panelTop / 100) * cH);
  const infoTop = isSquareLayout()
    ? infoTopBase - (squareCongestion * SQUARE_VIEW.adaptivePanelTopShiftUpMaxPx)
    : mobile
      ? infoTopBase - mobileAdaptive.panelTopShiftUp
      : infoTopBase;
  info.style.top    = infoTop + 'px';
  info.style.right  = ((p.panelRight  / 100) * cW) + 'px';
  info.style.bottom = ((p.panelBottom / 100) * cH) + 'px';
  info.style.overflow = isSquareLayout() ? 'visible' : 'hidden';

  let donutTop = (cy - d / 2);
  if (isSquareLayout() || mobile) {
    const headerEl = document.getElementById('cardHeader');
    const cardRect = cardEl.getBoundingClientRect();
    const headerBottom = headerEl ? (headerEl.getBoundingClientRect().bottom - cardRect.top) : 0;
    const zonePad = isSquareLayout() ? 8 : 10;
    const zoneTop = Math.max(0, headerBottom + zonePad);
    const zoneBottom = Math.max(zoneTop + d, infoTop - zonePad);
    const zoneHeight = Math.max(0, zoneBottom - zoneTop);
    if (zoneHeight >= d + 2) {
      donutTop = zoneTop + ((zoneHeight - d) / 2);
    }
  }
  wrap.style.width  = d + 'px';
  wrap.style.height = d + 'px';
  wrap.style.left   = (cx - d / 2) + 'px';
  wrap.style.top    = donutTop + 'px';

  /* More vertical breathing room in mobile/stacked layouts */
  info.style.gap = isMobileLayout()
    ? `${Math.max(2, (parseFloat(MOBILE_VIEW.sourcesOutgroupsGap) || 20) - mobileAdaptive.gapReduce)}px`
    : isSquareLayout()
      ? `${Math.max(2, squareSpace(SQUARE_VIEW.infoGapMinPx, SQUARE_VIEW.infoGapMaxPx) - (squareCongestion * SQUARE_VIEW.adaptiveInfoGapReduceMaxPx))}px`
      : '10px';

  /* Desktop table font scaling for landscape modes */
  if (!isMobileLayout() && !isSquareLayout()) {
    const scale = Math.min(1, cW / 780);
    document.querySelectorAll('#sourcesBox .pop-name').forEach(el => {
      el.style.fontSize = Math.max(10, Math.round(17 * scale)) + 'px';
    });
    document.querySelectorAll('#sourcesBox .coeff-text').forEach(el => {
      el.style.fontSize = Math.max(10, Math.round(17 * scale)) + 'px';
    });
    document.querySelectorAll('#sourcesBox .z-text').forEach(el => {
      el.style.fontSize = Math.max(9, Math.round(15 * scale)) + 'px';
    });
  }

  if (isSquareLayout()) {
    applySquareDynamicSourcesWidth();
  }

  if (!isMobileLayout()) {
    balanceDesktopSourceColumns({ dataWrap: isSquareLayout() ? !!SQUARE_VIEW.dynamicColumns : true });
  }
}

/* ═══════════════════════════════════════════════════════════════════════
   UTILITIES
═══════════════════════════════════════════════════════════════════════ */
function applyT(el, t) {
  if (!el || !t) return;
  if (t.font)          el.style.fontFamily    = t.font;
  if (t.fontSize)      el.style.fontSize      = t.fontSize;
  if (t.fontWeight)    el.style.fontWeight    = t.fontWeight;
  if (t.fontStyle)     el.style.fontStyle     = t.fontStyle;
  if (t.color)         el.style.color         = t.color;
  if (t.letterSpacing) el.style.letterSpacing = t.letterSpacing;
  if (t.lineHeight)    el.style.lineHeight    = t.lineHeight;
  if (t.align)         el.style.textAlign     = t.align;
}

function applySignature() {
  const wmEl = document.getElementById('watermark');
  if (!wmEl) return;

  if (!SIGNATURE.enabled || !SIGNATURE.text) {
    wmEl.style.display = 'none';
    wmEl.innerHTML = '';
    return;
  }

  wmEl.style.display = 'block';
  wmEl.innerHTML = '';
  Array.from(String(SIGNATURE.text)).forEach((ch) => {
    const span = document.createElement('span');
    span.className = 'sig-ch';
    span.textContent = ch === ' ' ? '\u00A0' : ch;
    wmEl.appendChild(span);
  });

  /* Start from themed watermark defaults, then apply signature overrides */
  applyT(wmEl, TYPOGRAPHY.watermark);

  if (SIGNATURE.fontFamily)    wmEl.style.fontFamily = SIGNATURE.fontFamily;
  if (SIGNATURE.fontSize)      wmEl.style.fontSize = SIGNATURE.fontSize;
  if (SIGNATURE.fontWeight)    wmEl.style.fontWeight = SIGNATURE.fontWeight;
  if (SIGNATURE.fontStyle)     wmEl.style.fontStyle = SIGNATURE.fontStyle;
  if (SIGNATURE.letterSpacing !== undefined) wmEl.style.letterSpacing = SIGNATURE.letterSpacing;
  if (SIGNATURE.lineHeight)    wmEl.style.lineHeight = SIGNATURE.lineHeight;
  if (SIGNATURE.color)         wmEl.style.color = SIGNATURE.color;

  const op = Number(SIGNATURE.opacity);
  wmEl.style.opacity = String(isNaN(op) ? 1 : Math.max(0, Math.min(1, op)));
  wmEl.style.right = `${Number(SIGNATURE.rightInsetPx) || 0}px`;
  wmEl.style.bottom = `${Number(SIGNATURE.bottomInsetPx) || 0}px`;
  wmEl.style.zIndex = String(Number(SIGNATURE.zIndex) || 6);
}

function radiusCss(v, fallback = '2px') {
  if (v === undefined || v === null) return fallback;
  const s = String(v).trim();
  if (!s) return fallback;
  if (/^\d+(\.\d+)?$/.test(s)) return `${Math.max(0, parseFloat(s))}px`;
  return s;
}

function tableRadiusFor(role) {
  const fallback = TABLE_STYLE.boxBorderRadius || '2px';
  if (isSquareLayout()) {
    return radiusCss(role === 'outgroups' ? TABLE_RADIUS.squareOutgroups : TABLE_RADIUS.squareSources, fallback);
  }
  if (isMobileLayout()) {
    return radiusCss(role === 'outgroups' ? TABLE_RADIUS.mobileOutgroups : TABLE_RADIUS.mobileSources, fallback);
  }
  return radiusCss(role === 'outgroups' ? TABLE_RADIUS.globalOutgroups : TABLE_RADIUS.globalSources, fallback);
}

function applyTableStyle(boxEl, role = 'sources') {
  if (!boxEl) return;
  const ts = TABLE_STYLE;
  boxEl.style.border       = `${ts.boxBorderWidth} solid ${ts.boxBorderColor}`;
  boxEl.style.borderRadius = tableRadiusFor(role);
}

function applyTableStylesForCurrentLayout() {
  applyTableStyle(document.getElementById('sourcesBox'), 'sources');
  applyTableStyle(document.getElementById('outgroupsBox'), 'outgroups');
}

/*
 * applyVerdictPos
 * Desktop: top-right (per VERDICT_POS config)
 * Mobile (isMobileLayout): near donut top-right (below stats region)
 *
 * FIX: use getBoundingClientRect() with offsetWidth/Height fallback so
 * dimensions are still available when paint is suppressed (hidden tab, etc.)
 */
function applyVerdictPos(vb, verdictType) {
  const cardEl = document.getElementById('card');
  const donutEl = document.getElementById('donutWrap');
  const cW = cardEl.offsetWidth, cH = cardEl.offsetHeight;
  const vp = VERDICT_POS;
  const mobile = isMobileLayout();
  const square = isSquareLayout();

  const anchorX = vp.anchorX;
  const anchorY = vp.anchorY;
  const anchor  = mobile ? 'top-right' : (vp.anchor || 'top-right');

  applyT(vb, TYPOGRAPHY.verdict);
  if (mobile) vb.style.fontSize = MOBILE_VIEW.verdictFontSize;
  else if (square) vb.style.fontSize = SQUARE_VIEW.verdictFontSize;

  switch (verdictType) {
    case 'pass': vb.style.background = vp.passBg; vb.style.color = vp.passText; break;
    case 'weak': vb.style.background = vp.weakBg; vb.style.color = vp.weakText; break;
    default:     vb.style.background = vp.failBg; vb.style.color = vp.failText;
  }
  vb.style.padding   = mobile
    ? `${MOBILE_VIEW.verdictPaddingV}px ${MOBILE_VIEW.verdictPaddingH}px`
    : square
      ? `${SQUARE_VIEW.verdictPaddingV}px ${SQUARE_VIEW.verdictPaddingH}px`
    : `${vp.paddingV}px ${vp.paddingH}px`;
  vb.style.textAlign = vp.textAlign;
  if (vp.minWidth  > 0) vb.style.minWidth  = vp.minWidth  + 'px';
  if (vp.minHeight > 0) vb.style.minHeight = vp.minHeight + 'px';

  /* FIX: use getBoundingClientRect (more reliable than offsetWidth during
     suppressed paint); fall back to offsetWidth/Height if rect is zero. */
  vb.style.visibility = 'hidden';
  vb.style.left = '0'; vb.style.top = '0'; vb.style.right = ''; vb.style.bottom = '';
  const bRect = vb.getBoundingClientRect();
  const bW = (bRect.width  > 0 ? bRect.width  : vb.offsetWidth)  || 60;
  const bH = (bRect.height > 0 ? bRect.height : vb.offsetHeight) || 28;
  vb.style.visibility = '';

  let ax = (anchorX / 100) * cW;
  let ay = (anchorY / 100) * cH;
  if (mobile && donutEl) {
    ay = donutEl.offsetTop + MOBILE_VIEW.verdictOffsetY;
  }
  const hP = anchor.includes('left') ? 0 : anchor.includes('right') ? 1 : 0.5;
  const vP = anchor.includes('bottom') ? 1 : 0;
  if (mobile && donutEl) {
    const useCardRight = MOBILE_VIEW.verdictAnchorX === 'card-right';
    const mobileLeft = useCardRight
      ? (cW - MOBILE_VIEW.verdictRightInsetPx - bW + MOBILE_VIEW.verdictOffsetX)
      : (donutEl.offsetLeft + donutEl.offsetWidth - bW + MOBILE_VIEW.verdictOffsetX);
    vb.style.left = mobileLeft + 'px';
    vb.style.top  = (donutEl.offsetTop + MOBILE_VIEW.verdictOffsetY) + 'px';
  } else {
    vb.style.left = (ax - hP * bW) + 'px';
    vb.style.top  = (ay - vP * bH) + 'px';
  }
  vb.style.right = ''; vb.style.bottom = '';
}

function setFormatBadge(text, cls) {
  const b = document.getElementById('formatBadge');
  if (!text) { b.style.display = 'none'; return; }
  b.textContent = text; b.className = cls; b.style.display = 'inline-block';
}
function showBadgeError(msg) {
  const s = msg.length > 52 ? msg.slice(0,50) + '…' : msg;
  setFormatBadge('✕ ' + s, 'error');
}

/*
 * updateSourceColors
 * Always receives colors in original source order.
 * data-seg-swatch index matches original source index.
 */
function updateSourceColors(origOrderColors) {
  document.querySelectorAll('[data-seg-swatch]').forEach((el) => {
    const i = parseInt(el.dataset.segSwatch);
    el.style.background = (i < origOrderColors.length) ? origOrderColors[i] : '#888888';
  });
}

/* HTML-only helper — do not use with textContent or setAttribute */
function softBreak(s) { return s.replace(/([_.\-])/g, '$1<wbr>'); }

function zColor(z) {
  const a = Math.abs(z);
  return a >= CFG.zGoodMin ? Z_COLORS.zGood : a >= CFG.zMidMin ? Z_COLORS.zMid : Z_COLORS.zBad;
}

function mergeRow(i) {
  const base = {
    nameFont: TYPOGRAPHY.sourcesName.font,
    nameFontSize: TYPOGRAPHY.sourcesName.fontSize,
    nameFontWeight: TYPOGRAPHY.sourcesName.fontWeight,
    nameFontStyle: 'normal',
    nameColor: TYPOGRAPHY.sourcesName.color,
    nameLetterSpacing: '0',
    nameLineHeight: '1.35',
    nameAlign: TYPOGRAPHY.sourcesName.align,
    coeffFont: TYPOGRAPHY.sourcesCoeff.font,
    coeffFontSize: TYPOGRAPHY.sourcesCoeff.fontSize,
    coeffFontWeight: TYPOGRAPHY.sourcesCoeff.fontWeight,
    coeffFontStyle: 'normal',
    coeffColor: TYPOGRAPHY.sourcesCoeff.color,
    coeffLetterSpacing: '0',
    coeffAlign: TYPOGRAPHY.sourcesCoeff.align,
    zFont: TYPOGRAPHY.sourcesZ.font,
    zFontSize: TYPOGRAPHY.sourcesZ.fontSize,
    zFontWeight: TYPOGRAPHY.sourcesZ.fontWeight,
    zFontStyle: 'normal',
    zLetterSpacing: '0',
  };
  const ov = TYPOGRAPHY.sourcesRowOverrides.find(r => r.index === i);
  return ov ? Object.assign({}, base, ov) : base;
}

/* ═══════════════════════════════════════════════════════════════════════
   VERDICT
═══════════════════════════════════════════════════════════════════════ */
function resolveVerdict(weights, sesPct, zScores, pValue) {
  const c       = VERDICT_CFG;
  const minAbsZ = Math.min(...zScores.map(z => Math.abs(z)));
  const minW    = Math.min(...weights);
  const relSEs  = sesPct.map((se, i) => weights[i] >= c.minWtForSE ? se / weights[i] : null).filter(v => v !== null);
  const maxRelSE = relSEs.length ? Math.max(...relSEs) : 0;
  if (pValue < c.pValueFail || minAbsZ < c.minZFail || minW < c.minWeightFail || maxRelSE > c.maxRelSEFail)
    return 'fail';
  if (minAbsZ >= c.minZStrong && maxRelSE <= c.maxRelSEStrong && weights.length <= c.maxSourcesStrong)
    return 'pass';
  return 'weak';
}

/* ═══════════════════════════════════════════════════════════════════════
   PARSERS
═══════════════════════════════════════════════════════════════════════ */
function isRawFormat(t) { return /left pops\s*:/i.test(t) && /right pops\s*:/i.test(t); }

function parseRaw(text) {
  const lines = text.split('\n');
  const li = lines.findIndex(l => /^\s*left pops\s*:/i.test(l));
  if (li < 0) throw new Error('"left pops:" not found');
  const lp = [];
  for (let i = li+1; i < lines.length; i++) {
    const l = lines[i].trim();
    if (!l || /^right pops/i.test(l)) break;
    const m = l.match(/^(\S+)\s+\d+/); if (m) lp.push(m[1]);
  }
  if (lp.length < 2) throw new Error('Need target + ≥1 source in left pops');
  const target = lp[0], sources = lp.slice(1);

  const ri = lines.findIndex(l => /^\s*right pops\s*:/i.test(l));
  const rp = [];
  if (ri >= 0) {
    for (let i = ri+1; i < lines.length; i++) {
      const l = lines[i].trim();
      if (!l || /^(left pops|codimension|f4rank|best coeff)/i.test(l)) break;
      const m = l.match(/^(\S+)\s+\d+/); if (m) rp.push(m[1]);
    }
  }

  let pValue = NaN, chisq = NaN;
  const ci = lines.findIndex(l => /^\s*codimension\s+1\b/.test(l));
  if (ci >= 0) {
    for (let i = ci+1; i < Math.min(ci+6, lines.length); i++) {
      const m = lines[i].match(/f4rank:.*?chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m) { chisq = parseFloat(m[1]); pValue = parseFloat(m[2]); break; }
    }
  }
  if (isNaN(pValue)) {
    for (const l of lines) {
      const m = l.match(/f4rank:.*?dof:\s*(\d+)\s+chisq:\s*([\d.]+)\s+tail:\s*([\d.eE+\-]+)/);
      if (m && parseInt(m[1]) > 0) { chisq = parseFloat(m[2]); pValue = parseFloat(m[3]); break; }
    }
  }
  if (isNaN(pValue)) throw new Error('Could not parse p-value (codimension 1 block needed)');

  const cl = lines.find(l => /best coefficients:/.test(l));
  if (!cl) throw new Error('"best coefficients:" not found');
  const coeffs = cl.replace('best coefficients:','').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (coeffs.length !== sources.length) throw new Error(`Coefficients (${coeffs.length}) ≠ sources (${sources.length})`);

  const sl = lines.find(l => /std\.\s*errors:/.test(l));
  if (!sl) throw new Error('"std. errors:" not found');
  const ses = sl.replace(/std\.\s*errors:/,'').trim().split(/\s+/).map(Number).filter(v=>!isNaN(v));
  if (ses.length !== sources.length) throw new Error(`SEs (${ses.length}) ≠ sources (${sources.length})`);

  const tot = coeffs.reduce((a,b)=>a+b,0);
  /* FIX: guard against degenerate all-zero coefficient case */
  if (tot === 0) throw new Error('All coefficients are zero — cannot normalise weights');
  return {
    target, sources,
    weights: coeffs.map(c=>(c/tot)*100),
    sesPct:  ses.map(s=>s*100),
    zScores: coeffs.map((c,i)=>ses[i]>0 ? c/ses[i] : 0),
    pValue, chisq, outgroups: rp.join(', '),
  };
}

/* FIX: the original regex used [\d.]+ for the weight value, which cannot
   match negative numbers like -5.2. The separator ' - ' (space-dash-space)
   is now matched explicitly with \s+-\s+ so the weight capture group can
   safely use [-\d.]+ without ambiguity. */
function parseSummary(text) {
  const lines = text.split('\n').map(l=>l.trim()).filter(Boolean);
  const tl = lines.find(l=>l.startsWith('Target:'));
  if (!tl) throw new Error('Target line not found');
  const target = tl.replace('Target:','').trim();
  const ws = lines.findIndex(l=>l.startsWith('Weights:'));
  if (ws < 0) throw new Error('Weights section not found');
  const pvl = lines.find(l=>l.startsWith('P value:'));
  const chl = lines.find(l=>l.startsWith('chisq:'));
  if (!pvl) throw new Error('P value not found');
  if (!chl)  throw new Error('chisq not found');
  const pValue    = parseFloat(pvl.replace('P value:','').trim());
  const chisq     = parseFloat(chl.replace('chisq:','').trim());
  const rgl       = lines.find(l=>l.startsWith('Rights:'));
  const outgroups = rgl ? rgl.replace('Rights:','').trim() : '';
  const sources=[],weights=[],sesPct=[],zScores=[];
  for (let i = ws+1; i < lines.length; i++) {
    const l = lines[i];
    if (/^(P value:|chisq:|Rights:)/.test(l)) break;
    /* Use \s+-\s+ for the separator so weight capture can be [-\d.]+ */
    const m = l.match(/^(.+?)\s+-\s+([-\d.]+)%\s+SE:\s+([-\d.]+)%\s+Z:\s+([-\d.]+)/);
    if (m) {
      sources.push(m[1].trim());
      weights.push(parseFloat(m[2]));
      sesPct.push(parseFloat(m[3]));
      zScores.push(parseFloat(m[4]));
    }
  }
  if (!sources.length) throw new Error('No populations found in Weights block');
  const tot = weights.reduce((a,b)=>a+b,0);
  return { target, sources, weights: weights.map(w=>(w/tot)*100), sesPct, zScores, pValue, chisq, outgroups };
}

/* ═══════════════════════════════════════════════════════════════════════
   LABEL COLOUR HELPER
═══════════════════════════════════════════════════════════════════════ */
function labelColorFor(hex) {
  if (!hex || hex.length < 7) return '#ffffff';
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return (0.299*r + 0.587*g + 0.114*b) / 255 > 0.55 ? '#111111' : '#ffffff';
}

/* ═══════════════════════════════════════════════════════════════════════
   SOURCE TABLE RENDERERS
   renderSourcesDesktop — standard 3-col table (non-mobile views)
   renderSourcesMobile  — stacked card layout (mobile / portrait)

   ── FIX 3, 4, 5 ──
   Mobile layout: full-width stacked cards, elongated color bar swatch,
   bigger fonts, more whitespace, no columns.
   Desktop layout: unchanged.
═══════════════════════════════════════════════════════════════════════ */
function renderSourcesDesktop(sources, weights, sesPct, zScores, colors) {
  const ts = TABLE_STYLE;
  const sh = TYPOGRAPHY.sourcesHeader;
  const zT = TYPOGRAPHY.sourcesZ;
  const sc = TYPOGRAPHY.sourcesColon;
  const square = isSquareLayout();
  const sqFontScale = 1; /* keep declared square font sizes unless overflow fallback is needed */
  const sPx = (v, min) => {
    const n = parseFloat(v);
    if (isNaN(n)) return v;
    return `${Math.max(min, Math.round(n * sqFontScale))}px`;
  };
  const squareDynamicCols = square && !!SQUARE_VIEW.dynamicColumns;
  const dataWrap = square ? squareDynamicCols : true;
  const sqPressure = square ? Math.max(0, Math.min(1, squareFitPressure)) : 0;
  const swatchCfg = square
    ? {
        width: SQUARE_VIEW.swatchWidth,
        height: SQUARE_VIEW.swatchHeight,
        radius: SQUARE_VIEW.swatchRadius,
        border: SQUARE_VIEW.swatchBorder,
      }
    : SWATCH;
  const hdrFontSize = square ? sPx(SQUARE_VIEW.sourcesHeaderFontSize, 12) : sh.fontSize;
  const tableLayout = square ? SQUARE_VIEW.tableLayoutMode : 'auto';
  const dataColWidth = square ? SQUARE_VIEW.dataColWidth : '220px';
  const headerPadY = square
    ? Math.max(2, squareSpace(SQUARE_VIEW.tableHeaderPadYMinPx, SQUARE_VIEW.tableHeaderPadYMaxPx) - Math.round(3 * sqPressure))
    : 5;
  const cellPadY   = square
    ? Math.max(2, squareSpace(SQUARE_VIEW.tableCellPadYMinPx, SQUARE_VIEW.tableCellPadYMaxPx) - Math.round(4 * sqPressure))
    : 5;
  const cellPadX   = square ? squareSpace(SQUARE_VIEW.tableCellPadXMinPx, SQUARE_VIEW.tableCellPadXMaxPx) : 10;
  const swatchColWidth = square ? `${Math.max(24, Number(SQUARE_VIEW.swatchColWidthPx) || 40)}px` : '40px';
  const swatchCellWidth = square ? `${Math.max(24, Number(SQUARE_VIEW.swatchCellWidthPx) || 44)}px` : '44px';
  const swatchPadLeft = square ? `${Math.max(0, Number(SQUARE_VIEW.swatchPadLeftPx) || 0)}px` : `${cellPadX}px`;
  const swatchPadRight = square ? `${Math.max(0, Number(SQUARE_VIEW.swatchPadRightPx) || 0)}px` : '0px';

  document.getElementById('sourcesBox').innerHTML = `
    <table class="data-table" id="sourcesTable" style="border-collapse:collapse;width:100%;table-layout:${tableLayout};">
      <colgroup>
        <col class="col-sw-col" style="width:${swatchColWidth};">
        <col class="col-name-col">
        <col class="col-data-col" style="${(square && !squareDynamicCols) ? `width:${dataColWidth};` : ''}">
      </colgroup>
      <thead id="sourcesHead"></thead>
      <tbody id="sourcesBody"></tbody>
    </table>`;

  document.getElementById('sourcesHead').innerHTML = `
    <tr>
      <th colspan="3" style="
        font-family:${sh.font};font-size:${hdrFontSize};font-weight:${sh.fontWeight};
        color:${sh.color};letter-spacing:${sh.letterSpacing};line-height:${sh.lineHeight};
        text-align:${sh.align};text-transform:${sh.textTransform||'uppercase'};
        background:${ts.headerBg};
        border-bottom:${ts.headerBorderWidth} solid ${ts.headerBorderColor};
        padding:${headerPadY}px ${cellPadX}px;white-space:nowrap;">
        ${sh.text}
      </th>
    </tr>`;

  let srcHTML = '';
  sources.forEach((pop, i) => {
    const rs     = mergeRow(i);
    const nameFamily  = square ? SQUARE_VIEW.sourcesNameFontFamily  : rs.nameFont;
    const nameSize  = square ? sPx(SQUARE_VIEW.sourcesNameFontSize, 12)  : rs.nameFontSize;
    const coeffFamily = square ? SQUARE_VIEW.sourcesCoeffFontFamily : rs.coeffFont;
    const coeffSize = square ? sPx(SQUARE_VIEW.sourcesCoeffFontSize, 11) : rs.coeffFontSize;
    const zFamily    = square ? SQUARE_VIEW.sourcesZFontFamily     : rs.zFont;
    const zSize     = square ? sPx(SQUARE_VIEW.sourcesZFontSize, 10)     : rs.zFontSize;
    const nameWeight = square ? SQUARE_VIEW.sourcesNameFontWeight : rs.nameFontWeight;
    const coeffWeight = square ? SQUARE_VIEW.sourcesCoeffFontWeight : rs.coeffFontWeight;
    const zWeight = square ? SQUARE_VIEW.sourcesZFontWeight : rs.zFontWeight;
    const nameStyle = square ? SQUARE_VIEW.sourcesNameFontStyle : (rs.nameFontStyle || 'normal');
    const coeffStyle = square ? SQUARE_VIEW.sourcesCoeffFontStyle : (rs.coeffFontStyle || 'normal');
    const zStyle = square ? SQUARE_VIEW.sourcesZFontStyle : (rs.zFontStyle || 'normal');
    const z      = zScores[i];
    const zCol   = zColor(z);
    const rowBg  = (i % 2 === 0) ? ts.evenRowBg : ts.oddRowBg;
    const cellBg = ts.cellBg !== 'transparent' ? ts.cellBg : rowBg;
    const isLast = i === sources.length - 1;
    const rowBdr = isLast ? '' : `border-bottom:${ts.rowBorderWidth} solid ${ts.rowBorderColor};`;

    const zToken  = `(Z:\u00A0${z.toFixed(2)})`;
    const zHtml   = `<span class="z-text" style="font-family:${zFamily};font-size:${zSize};font-weight:${zWeight};font-style:${zStyle};color:${zCol};white-space:nowrap;display:inline-block;vertical-align:baseline;">${zToken}</span>`;
    const zSep    = `<span style="display:inline-block;width:${zT.zSepPx}px;"></span>`;
    const colHtml = `<span style="font-family:${square ? coeffFamily : sc.colonFont};color:${sc.colonColor};white-space:${dataWrap ? 'normal' : 'pre'};">${sc.colonText}</span>`;
    const coHtml  = `<span class="coeff-text" style="font-family:${coeffFamily};font-size:${coeffSize};font-weight:${coeffWeight};font-style:${coeffStyle};color:${rs.coeffColor};white-space:${dataWrap ? 'normal' : 'nowrap'};vertical-align:baseline;">${weights[i].toFixed(1)}% \u00B1 ${sesPct[i].toFixed(2)}%</span>`;
    const dataHtml = `${colHtml}${coHtml}${zSep}${zHtml}`;

    srcHTML += `<tr style="background:${rowBg};">
      <td class="col-sw" style="width:${swatchCellWidth};padding:${cellPadY}px ${swatchPadRight} ${cellPadY}px ${swatchPadLeft} !important;vertical-align:middle;${rowBdr}background:${cellBg};">
        <span class="swatch" data-seg-swatch="${i}" style="background:${colors[i]};width:${swatchCfg.width};height:${swatchCfg.height};border-radius:${swatchCfg.radius};border:${swatchCfg.border};display:inline-block;"></span>
      </td>
      <td class="col-name" style="text-align:${rs.nameAlign};padding:${cellPadY}px 4px !important;vertical-align:middle;${rowBdr}background:${cellBg};">
        <span class="pop-name" style="font-family:${nameFamily};font-size:${nameSize};font-weight:${nameWeight};font-style:${nameStyle};color:${rs.nameColor};line-height:${rs.nameLineHeight};">${softBreak(pop)}</span>
      </td>
      <td class="col-data" style="text-align:${rs.coeffAlign};white-space:${dataWrap ? 'normal' : 'nowrap'};overflow-wrap:anywhere;word-break:break-word;padding:${cellPadY}px ${cellPadX}px;vertical-align:middle;${rowBdr}background:${cellBg};">${dataHtml}</td>
    </tr>`;
  });
  document.getElementById('sourcesBody').innerHTML = srcHTML;

  balanceDesktopSourceColumns({ dataWrap });
}

function balanceDesktopSourceColumns({ dataWrap = true } = {}) {
  if (isMobileLayout()) return;
  const table = document.getElementById('sourcesTable');
  if (!table) return;

  const swCol = table.querySelector('col.col-sw-col');
  const nameCol = table.querySelector('col.col-name-col');
  const dataCol = table.querySelector('col.col-data-col');
  if (!swCol || !nameCol || !dataCol) return;

  const square = isSquareLayout();
  let tW = table.clientWidth || table.getBoundingClientRect().width;
  let swW = swCol.getBoundingClientRect().width || parseFloat(swCol.style.width) || 40;
  let avail = Math.max(180, tW - swW);
  let nameW = avail * 0.5; /* start symmetric 50/50 */
  let dataW = avail - nameW;
  let minName = Math.max(110, avail * 0.28);
  let minData = Math.max(150, avail * 0.30);
  const setCols = () => {
    nameCol.style.width = `${Math.round(nameW)}px`;
    dataCol.style.width = `${Math.round(dataW)}px`;
  };
  const recalcAvail = (preserveRatio = true) => {
    const ratio = (nameW + dataW) > 0 ? (nameW / (nameW + dataW)) : 0.5;
    tW = table.clientWidth || table.getBoundingClientRect().width;
    swW = swCol.getBoundingClientRect().width || parseFloat(swCol.style.width) || 40;
    avail = Math.max(180, tW - swW);
    minName = Math.max(110, avail * 0.28);
    minData = Math.max(150, avail * 0.30);
    if (preserveRatio) {
      nameW = Math.max(minName, Math.min(avail - minData, avail * ratio));
    } else {
      nameW = Math.max(minName, Math.min(avail - minData, avail * 0.5));
    }
    dataW = avail - nameW;
  };
  recalcAvail(false);
  setCols();

  const nameCells = Array.from(table.querySelectorAll('td.col-name'));
  const dataCells = Array.from(table.querySelectorAll('td.col-data'));
  if (!nameCells.length || !dataCells.length) return;

  const prevNameWs = nameCells.map(el => el.style.whiteSpace);
  const prevDataWs = dataCells.map(el => el.style.whiteSpace);
  const setWrapState = (wrap, forceNoWrap = false) => {
    nameCells.forEach((el, i) => {
      const baseNoWrap = forceNoWrap ? 'nowrap' : (square ? 'nowrap' : (prevNameWs[i] || 'normal'));
      el.style.whiteSpace = wrap ? 'normal' : baseNoWrap;
    });
    dataCells.forEach((el, i) => {
      const baseNoWrap = forceNoWrap ? 'nowrap' : (square ? 'nowrap' : (prevDataWs[i] || 'nowrap'));
      el.style.whiteSpace = wrap ? 'normal' : baseNoWrap;
      if (wrap) {
        el.style.overflowWrap = 'anywhere';
        el.style.wordBreak = 'break-word';
      } else {
        el.style.overflowWrap = '';
        el.style.wordBreak = '';
      }
    });
  };

  const maxOverflow = (cells) =>
    cells.reduce((m, el) => Math.max(m, (el.scrollWidth || 0) - (el.clientWidth || 0)), 0);
  const rowOverflow = () =>
    nameCells.map((nEl, i) => ({
      n: Math.max(0, (nEl.scrollWidth || 0) - (nEl.clientWidth || 0)),
      d: Math.max(0, ((dataCells[i] && dataCells[i].scrollWidth) || 0) - ((dataCells[i] && dataCells[i].clientWidth) || 0)),
    }));
  const getVerticalOverflow = () => {
    if (!square) return 0;
    const infoEl = document.getElementById('infoCol');
    const sourcesBox = document.getElementById('sourcesBox');
    const sourcesTable = document.getElementById('sourcesTable');
    const outgroupsBox = document.getElementById('outgroupsBox');
    const outgroupsTable = document.getElementById('outgroupsTable');
    const outgroupsFoot = document.getElementById('outgroupsFoot');
    let over = 0;
    if (infoEl) over = Math.max(over, (infoEl.scrollHeight || 0) - (infoEl.clientHeight || 0));
    if (sourcesBox && sourcesTable) {
      over = Math.max(over, (sourcesTable.scrollHeight || 0) - (sourcesBox.clientHeight || 0));
    }
    if (outgroupsBox && outgroupsTable && outgroupsBox.style.display !== 'none') {
      over = Math.max(over, (outgroupsTable.scrollHeight || 0) - (outgroupsBox.clientHeight || 0));
    }
    if (outgroupsFoot && outgroupsFoot.style.display !== 'none') {
      over = Math.max(over, (outgroupsFoot.scrollHeight || 0) - (outgroupsFoot.clientHeight || 0));
    }
    return Math.max(0, over);
  };
  let nameOver = 0;
  let dataOver = 0;
  const recomputeOverflow = () => {
    nameOver = maxOverflow(nameCells);
    dataOver = maxOverflow(dataCells);
  };

  const rebalanceTowardOverflow = () => {
    const movable = Math.max(0, avail - (minName + minData));
    if (movable <= 0) return;
    if (dataOver > nameOver) {
      const shift = Math.min(movable, Math.max(0, (dataOver - nameOver) * 1.2));
      nameW = Math.max(minName, nameW - shift);
      dataW = avail - nameW;
    } else if (nameOver > dataOver) {
      const shift = Math.min(movable, Math.max(0, (nameOver - dataOver) * 1.2));
      dataW = Math.max(minData, dataW - shift);
      nameW = avail - dataW;
    }
    setCols();
    recomputeOverflow();
  };

  const tryGrowSquareWidth = (maxPctCap = null) => {
    if (!square || !SQUARE_VIEW.tableWidthDynamic) return false;
    const sourcesBox = document.getElementById('sourcesBox');
    if (!sourcesBox) return false;
    const minPct = Math.max(20, Math.min(100, Number(SQUARE_VIEW.tableWidthPercent) || 70));
    const maxBase = Math.max(minPct, Math.min(100, Number(SQUARE_VIEW.tableWidthMaxPercent) || 100));
    const maxPct = maxPctCap == null
      ? maxBase
      : Math.max(minPct, Math.min(maxBase, Number(maxPctCap) || maxBase));
    const buffer = Math.max(1, Number(SQUARE_VIEW.tableWidthBufferRatio) || 1.2);
    const pct = Math.max(minPct, Math.min(maxPct, parseFloat(sourcesBox.style.width) || minPct));
    const boxW = Math.max(1, sourcesBox.clientWidth || 1);
    const vOver = getVerticalOverflow();
    const needPx = Math.max(nameOver, dataOver, vOver * 0.9);
    if (needPx <= 1) return false;
    const needScale = Math.max(1, ((boxW + needPx) / boxW) * buffer);
    const nextPct = Math.max(minPct, Math.min(maxPct, pct * needScale));
    if (nextPct <= pct + 0.2) return false;
    sourcesBox.style.width = `${nextPct}%`;
    return true;
  };

  const preWrapMaxPct = Math.max(
    Number(SQUARE_VIEW.tableWidthPercent) || 70,
    Math.min(
      Number(SQUARE_VIEW.tableWidthMaxPercent) || 100,
      Number(SQUARE_VIEW.preWrapWidthMaxPercent) || 80
    )
  );

  const noWrapPass = () => {
    setWrapState(false, true);
    recomputeOverflow();
    if (nameOver > 1 || dataOver > 1) rebalanceTowardOverflow();
    if (tryGrowSquareWidth(preWrapMaxPct)) {
      recalcAvail(true);
      setCols();
      recomputeOverflow();
      if (nameOver > 1 || dataOver > 1) rebalanceTowardOverflow();
    }
  };

  if (square) applySquareTableFontDropPx(0, 'all');
  noWrapPass();
  let verticalOver = getVerticalOverflow();

  if (square && (nameOver > 1 || dataOver > 1 || verticalOver > 1)) {
    let solved = false;
    const zMaxDrop = Math.max(0, Math.min(2, Number(SQUARE_VIEW.fitZOnlyMaxDropPx) || 2));
    for (let drop = 1; drop <= zMaxDrop; drop++) {
      applySquareTableFontDropPx(drop, 'z');
      noWrapPass();
      verticalOver = getVerticalOverflow();
      if (nameOver <= 1 && dataOver <= 1 && verticalOver <= 1) { solved = true; break; }
    }
    if (!solved) applySquareTableFontDropPx(0, 'z');

    if (!solved && (nameOver > 1 || dataOver > 1 || verticalOver > 1)) {
      const allMaxDrop = Math.max(0, Math.min(2, Number(SQUARE_VIEW.fitAllMaxDropPx) || 2));
      for (let drop = 1; drop <= allMaxDrop; drop++) {
        applySquareTableFontDropPx(drop, 'all');
        noWrapPass();
        verticalOver = getVerticalOverflow();
        if (nameOver <= 1 && dataOver <= 1 && verticalOver <= 1) { solved = true; break; }
      }
    }

    if (!solved) {
      /* As requested: reset to declared size before newline stage */
      applySquareTableFontDropPx(0, 'all');
      noWrapPass();
      verticalOver = getVerticalOverflow();
    }
  }

  /* Newline only if both columns overflow in at least one row */
  const bothOverflowSameRow = rowOverflow().some(r => r.n > 1 && r.d > 1);
  const allowWrap = dataWrap && bothOverflowSameRow;
  setWrapState(allowWrap, false);
  recalcAvail(true);
  setCols();
  recomputeOverflow();
  verticalOver = getVerticalOverflow();

  if (square) {
    let pressure = 0;
    const stillOverflowing = () => (nameOver > 1 || dataOver > 1 || verticalOver > 1);

    if (stillOverflowing()) {
      const finalMaxDrop = Math.max(0, Math.min(2, Number(SQUARE_VIEW.fitFinalAllMaxDropPx) || 2));
      let resolved = false;
      for (let drop = 1; drop <= finalMaxDrop; drop++) {
        applySquareTableFontDropPx(drop, 'all');
        setWrapState(allowWrap, !allowWrap);
        recalcAvail(true);
        setCols();
        recomputeOverflow();
        if (!allowWrap && (nameOver > 1 || dataOver > 1)) rebalanceTowardOverflow();
        if (tryGrowSquareWidth()) {
          recalcAvail(true);
          setCols();
          recomputeOverflow();
          if (!allowWrap && (nameOver > 1 || dataOver > 1)) rebalanceTowardOverflow();
        }
        setWrapState(allowWrap, !allowWrap);
        recomputeOverflow();
        verticalOver = getVerticalOverflow();
        if (!stillOverflowing()) {
          resolved = true;
          pressure = 0.45 + (drop * 0.2);
          break;
        }
      }

      if (!resolved && stillOverflowing()) {
        const infoEl = document.getElementById('infoCol');
        const infoH = Math.max(1, infoEl ? infoEl.clientHeight : 1);
        const hRatio = Math.max(nameOver, dataOver) / Math.max(1, avail * 0.18);
        const vRatio = verticalOver / Math.max(1, infoH * 0.18);
        pressure = Math.max(0.55, Math.min(1, Math.max(hRatio, vRatio)));
      }
    }

    squareFitPressure = Math.max(0, Math.min(1, pressure));
  }
}

function applySquareTableFontDropPx(dropPx, mode = 'all') {
  if (!isSquareLayout()) return;
  const clampedDrop = Math.max(0, Math.min(2, Number(dropPx) || 0));
  const selectors = mode === 'z'
    ? ['#sourcesBox .z-text']
    : ['#sourcesBox .pop-name', '#sourcesBox .coeff-text', '#sourcesBox .z-text', '#sourcesHead th'];
  const els = selectors.flatMap((sel) => Array.from(document.querySelectorAll(sel)));
  if (!els.length) return;
  els.forEach(el => {
    const cs = window.getComputedStyle(el);
    if (!el.dataset.baseFsSq) {
      const b = parseFloat(cs.fontSize);
      if (!isNaN(b) && b > 0) el.dataset.baseFsSq = String(b);
    }
    const base = parseFloat(el.dataset.baseFsSq || '');
    if (isNaN(base) || base <= 0) return;
    el.style.fontSize = `${Math.max(10, Math.round(base - clampedDrop))}px`;
  });
}

function applySquareTableFontScale(scale) {
  if (!isSquareLayout()) return;
  const clamped = Math.max(0.8, Math.min(1, Number(scale) || 1));
  const refs = Array.from(document.querySelectorAll('#sourcesBox .pop-name, #sourcesBox .coeff-text, #sourcesBox .z-text'));
  if (!refs.length) return;
  refs.forEach(el => {
    const cs = window.getComputedStyle(el);
    if (!el.dataset.baseFsSq) {
      const b = parseFloat(cs.fontSize);
      if (!isNaN(b) && b > 0) el.dataset.baseFsSq = String(b);
    }
  });
  const baseVals = refs
    .map(el => parseFloat(el.dataset.baseFsSq || ''))
    .filter(v => !isNaN(v) && v > 0);
  if (!baseVals.length) return;
  const avgBase = baseVals.reduce((a, b) => a + b, 0) / baseVals.length;
  const drop = Math.max(0, Math.min(2, Math.round(avgBase * (1 - clamped))));
  applySquareTableFontDropPx(drop, 'all');
}

/*
 * renderSourcesMobile  (portrait ratio on any screen, or real mobile screen)
 *
 * ── FIX 3: bigger fonts, more whitespace                ──
 * ── FIX 4: no columns, stacked cards                    ──
 * ── FIX 5: elongated color swatch spanning card height  ──
 *
 * Each source card:
 *   [ tall color bar ] | Source_Name
 *                      | coeff ± SE   (Z: score)
 */
function renderSourcesMobile(sources, weights, sesPct, zScores, colors) {
  const ts = TABLE_STYLE;
  const sh = TYPOGRAPHY.sourcesHeader;
  const zT = TYPOGRAPHY.sourcesZ;
  const mob = getMobileAdaptiveProfile();
  const px = (v, scale, min) => {
    const n = parseFloat(v);
    if (isNaN(n)) return v;
    return `${Math.max(min, Math.round(n * scale))}px`;
  };

  /* Mobile-specific font sizes — larger and more readable */
  const MOB_NAME_SIZE  = px(MOBILE_VIEW.sourcesNameFontSize, mob.fontScale, 14);
  const MOB_COEFF_SIZE = px(MOBILE_VIEW.sourcesCoeffFontSize, mob.fontScale, 13);
  const MOB_Z_SIZE     = px(MOBILE_VIEW.sourcesZFontSize, mob.fontScale, 12);
  const MOB_NAME_WEIGHT = MOBILE_VIEW.sourcesNameFontWeight;
  const MOB_NAME_STYLE  = MOBILE_VIEW.sourcesNameFontStyle;
  const MOB_COEFF_WEIGHT = MOBILE_VIEW.sourcesCoeffFontWeight;
  const MOB_COEFF_STYLE  = MOBILE_VIEW.sourcesCoeffFontStyle;
  const MOB_Z_WEIGHT = MOBILE_VIEW.sourcesZFontWeight;
  const MOB_Z_STYLE  = MOBILE_VIEW.sourcesZFontStyle;
  const MOB_NUMERIC_FONT = numericTableFontForLayout() || TYPOGRAPHY.sourcesCoeff.font;
  const MOB_HDR_SIZE   = px(MOBILE_VIEW.sourcesHeaderFontSize, mob.fontScale, 11);
  const rowScale = Math.max(0.55, mob.rowPadScale);
  const MOB_ROW_PAD_TOP = Math.max(4, Math.round((MOBILE_VIEW.sourcesRowPadTopPx || 10) * rowScale));
  const MOB_ROW_PAD_BOTTOM = Math.max(4, Math.round((MOBILE_VIEW.sourcesRowPadBottomPx || 10) * rowScale));
  const MOB_CARD_PAD_X = Math.max(12, Math.round(20 * mob.rowPadScale));
  const MOB_LAST_EXTRA_PAD = Math.max(4, Math.round((MOBILE_VIEW.sourcesLastRowExtraBottomPadPx || 8) * mob.rowPadScale));
  const MOB_SWATCH_INSET = Math.max(1, Math.round((MOBILE_VIEW.sourcesSwatchInsetPx || 2) * rowScale));
  const MOB_BOTTOM_PAD = MOBILE_VIEW.equalSourceRowHeights
    ? 0
    : Math.max(8, Math.round((MOBILE_VIEW.sourcesTableBottomPadPx || 12) * mob.rowPadScale));
  const MOB_BAR_W      = `${Math.max(4, Number(MOBILE_VIEW.sourcesSwatchBarWidthPx) || 13)}px`;
  const MOB_BAR_RADIUS = `${Math.max(0, Number(MOBILE_VIEW.sourcesSwatchBarRadiusPx) || 0)}px`;
  const MOB_BAR_BORDER_W = Math.max(0, Number(MOBILE_VIEW.sourcesSwatchBarBorderWidthPx) || 0);
  const MOB_BAR_BORDER = MOB_BAR_BORDER_W > 0
    ? `${MOB_BAR_BORDER_W}px solid ${MOBILE_VIEW.sourcesSwatchBarBorderColor || 'rgba(0,0,0,0.2)'}`
    : 'none';
  const ROW_GAP_Y = Math.max(4, Math.round(8 * rowScale));
  const ROW_GAP_X = Math.max(8, Math.round(16 * rowScale));
  const META_GAP_X = Math.max(8, Math.round(12 * rowScale));
  const META_GAP_Y = Math.max(4, Math.round(6 * rowScale));
  const namePx = parseFloat(MOB_NAME_SIZE) || 22;
  const coeffPx = parseFloat(MOB_COEFF_SIZE) || 20;
  const MOB_EQUAL_ROW_MIN_H = Math.max(
    72,
    Math.ceil((namePx * 1.25) + (coeffPx * 1.4) + ROW_GAP_Y + MOB_ROW_PAD_TOP + MOB_ROW_PAD_BOTTOM)
  );

  let html = `<div style="overflow:hidden;border-radius:2px;padding-bottom:${MOB_BOTTOM_PAD}px;">`;

  /* Section header */
  html += `<div style="
    font-family:${sh.font};
    font-size:${MOB_HDR_SIZE};
    font-weight:${sh.fontWeight};
    color:${sh.color};
    letter-spacing:${sh.letterSpacing};
    text-align:center;
    text-transform:uppercase;
    background:${ts.headerBg};
    border-bottom:${ts.headerBorderWidth} solid ${ts.headerBorderColor};
    padding:12px 20px;
    line-height:1.4;
  ">${sh.text}</div>`;

  sources.forEach((pop, i) => {
    const rs     = mergeRow(i);
    const z      = zScores[i];
    const zCol   = zColor(z);
    const rowBg  = (i % 2 === 0) ? ts.evenRowBg : ts.oddRowBg;
    const isLast = i === sources.length - 1;
    const borderBottom = `border-bottom:${ts.rowBorderWidth} solid ${ts.rowBorderColor};`;

    html += `<div style="
        display:flex;
        align-items:stretch;
        min-height:${MOBILE_VIEW.equalSourceRowHeights ? MOB_EQUAL_ROW_MIN_H : 0}px;
        padding:${MOB_ROW_PAD_TOP}px ${MOB_CARD_PAD_X}px ${MOB_ROW_PAD_BOTTOM + ((MOBILE_VIEW.equalSourceRowHeights ? 0 : (isLast ? MOB_LAST_EXTRA_PAD : 0)))}px ${MOB_CARD_PAD_X}px;
        gap:${ROW_GAP_X}px;
        background:${rowBg};
        ${borderBottom}
      ">
      <!-- Elongated swatch bar spanning the full row height -->
      <div data-seg-swatch="${i}" style="
        width:${MOB_BAR_W};
        min-width:${MOB_BAR_W};
        flex-shrink:0;
        align-self:stretch;
        margin-top:${MOB_SWATCH_INSET}px;
        margin-bottom:${MOB_SWATCH_INSET}px;
        min-height:${MOBILE_VIEW.equalSourceRowHeights ? Math.max(42, MOB_EQUAL_ROW_MIN_H - (2 * MOB_SWATCH_INSET)) : Math.max(42, Math.round(60 * mob.rowPadScale))}px;
        background:${colors[i]};
        border-radius:${MOB_BAR_RADIUS};
        border:${MOB_BAR_BORDER};
      "></div>

      <!-- Source name + data stacked vertically -->
      <div style="
        display:flex;
        flex-direction:column;
        gap:${ROW_GAP_Y}px;
        flex:1;
        min-width:0;
        justify-content:center;
      ">
        <!-- Source population name -->
        <div class="pop-name" style="
          font-family:${rs.nameFont};
          font-size:${MOB_NAME_SIZE};
          font-weight:${MOB_NAME_WEIGHT};
          font-style:${MOB_NAME_STYLE};
          color:${rs.nameColor};
          line-height:1.25;
          word-break:break-word;
          overflow-wrap:break-word;
        ">${softBreak(pop)}</div>

        <!-- Coefficient and Z-score on their own line -->
        <div style="
          display:flex;
          flex-wrap:wrap;
          align-items:baseline;
          gap:${META_GAP_Y}px ${META_GAP_X}px;
          line-height:1.4;
        ">
          <span class="coeff-text" style="
            font-family:${MOB_NUMERIC_FONT};
            font-size:${MOB_COEFF_SIZE};
            font-weight:${MOB_COEFF_WEIGHT};
            font-style:${MOB_COEFF_STYLE};
            color:${rs.coeffColor};
            white-space:nowrap;
          ">${weights[i].toFixed(1)}% \u00B1 ${sesPct[i].toFixed(2)}%</span>
          <span class="z-text" style="
            font-family:${MOB_NUMERIC_FONT};
            font-size:${MOB_Z_SIZE};
            font-weight:${MOB_Z_WEIGHT};
            font-style:${MOB_Z_STYLE};
            color:${zCol};
            white-space:nowrap;
          ">(${zT.zPrefix}${z.toFixed(2)})</span>
        </div>
      </div>
    </div>`;
  });

  html += `</div>`;
  document.getElementById('sourcesBox').innerHTML = html;
}

function applySquareDynamicSourcesWidth() {
  if (!isSquareLayout()) return;
  const sourcesBox = document.getElementById('sourcesBox');
  const sourcesTable = document.getElementById('sourcesTable');
  if (!sourcesBox || !sourcesTable) return;

  const minPct = Math.max(20, Math.min(100, Number(SQUARE_VIEW.tableWidthPercent) || 70));
  const maxPct = Math.max(minPct, Math.min(100, Number(SQUARE_VIEW.tableWidthMaxPercent) || 100));

  if (!SQUARE_VIEW.tableWidthDynamic) {
    sourcesBox.style.width = `${minPct}%`;
    return;
  }

  const buffer = Math.max(1, Number(SQUARE_VIEW.tableWidthBufferRatio) || 1.2);
  let pct = Math.max(minPct, Math.min(maxPct, parseFloat(sourcesBox.style.width) || minPct));
  const maxCellOverflow = () => {
    const cells = [
      ...sourcesTable.querySelectorAll('td.col-name'),
      ...sourcesTable.querySelectorAll('td.col-data'),
    ];
    if (!cells.length) return 0;
    return cells.reduce((m, el) => Math.max(m, (el.scrollWidth || 0) - (el.clientWidth || 0)), 0);
  };

  /* Grow only when actual overflow is measured; cap at maxPct. */
  for (let i = 0; i < 3; i++) {
    sourcesBox.style.width = `${pct}%`;
    const clientW = sourcesTable.clientWidth || 0;
    if (!clientW) break;
    const tableOverflow = Math.max(0, (sourcesTable.scrollWidth || 0) - clientW);
    const cellOverflow = Math.max(0, maxCellOverflow());
    const overflowPx = Math.max(tableOverflow, cellOverflow);
    if (overflowPx <= 1) break;
    const neededPct = pct * (((clientW + overflowPx) / clientW) * buffer);
    const nextPct = Math.max(minPct, Math.min(maxPct, neededPct));
    if (Math.abs(nextPct - pct) < 0.25) { pct = nextPct; break; }
    pct = nextPct;
  }

  sourcesBox.style.width = `${pct}%`;
}

function renderInfoPanelsForCurrentLayout() {
  if (!currentParsedData) return;

  const { sources, weights, sesPct, zScores, outgroups } = currentParsedData;
  const mobile = isMobileLayout();

  if (mobile) {
    renderSourcesMobile(sources, weights, sesPct, zScores, originalColors);
  } else {
    renderSourcesDesktop(sources, weights, sesPct, zScores, originalColors);
  }

  const ogBox = document.getElementById('outgroupsBox');
  const ogTd  = document.getElementById('outgroupsTd');
  const ogH   = document.getElementById('hdrOutgroups');
  const ogh   = TYPOGRAPHY.outgroupsHeader;
  const ts    = TABLE_STYLE;
  const square = isSquareLayout();
  const sqPressure = square ? Math.max(0, Math.min(1, squareFitPressure)) : 0;
  const sqFontScale = 1;
  const sqPx = (v, min) => {
    const n = parseFloat(v);
    if (isNaN(n)) return v;
    return `${Math.max(min, Math.round(n * sqFontScale))}px`;
  };
  const mob = getMobileAdaptiveProfile();
  const mPx = (v, scale, min) => {
    const n = parseFloat(v);
    if (isNaN(n)) return v;
    return `${Math.max(min, Math.round(n * scale))}px`;
  };
  const sourcesBox = document.getElementById('sourcesBox');
  const outgroupsBox = document.getElementById('outgroupsBox');
  const outgroupsFoot = document.getElementById('outgroupsFoot');
  const mobileBottomInset = Math.max(0, Number(MOBILE_VIEW.outgroupsBottomInsetPx) || 0);

  if (square) {
    const w = `${Math.max(20, Math.min(100, Number(SQUARE_VIEW.tableWidthPercent) || 70))}%`;
    sourcesBox.style.width = w;
    sourcesBox.style.marginLeft = 'auto';
    sourcesBox.style.marginRight = 'auto';
    sourcesBox.style.flexShrink = '0';
    sourcesBox.style.minHeight = 'fit-content';
    outgroupsBox.style.width = '';
    outgroupsBox.style.marginLeft = '';
    outgroupsBox.style.marginRight = '';
    outgroupsBox.style.flexShrink = '0';
    outgroupsFoot.style.width = '';
    outgroupsFoot.style.marginLeft = '';
    outgroupsFoot.style.marginRight = '';
    outgroupsFoot.style.flexShrink = '0';
    applySquareDynamicSourcesWidth();
    balanceDesktopSourceColumns({ dataWrap: !!SQUARE_VIEW.dynamicColumns });
  } else if (mobile) {
    const mobileW = Math.max(30, Math.min(100, Number(MOBILE_VIEW.tableWidthPercent) || 100));
    const w = `${mobileW}%`;
    sourcesBox.style.width = w;
    sourcesBox.style.marginLeft = 'auto';
    sourcesBox.style.marginRight = 'auto';
    outgroupsBox.style.width = w;
    outgroupsBox.style.marginLeft = 'auto';
    outgroupsBox.style.marginRight = 'auto';
    outgroupsFoot.style.width = '';
    outgroupsFoot.style.marginLeft = '';
    outgroupsFoot.style.marginRight = '';
    sourcesBox.style.flexShrink = '';
    sourcesBox.style.minHeight = '';
    outgroupsBox.style.flexShrink = '';
    outgroupsFoot.style.flexShrink = '';
  } else {
    sourcesBox.style.width = '';
    sourcesBox.style.marginLeft = '';
    sourcesBox.style.marginRight = '';
    outgroupsBox.style.width = '';
    outgroupsBox.style.marginLeft = '';
    outgroupsBox.style.marginRight = '';
    outgroupsFoot.style.width = '';
    outgroupsFoot.style.marginLeft = '';
    outgroupsFoot.style.marginRight = '';
    sourcesBox.style.flexShrink = '';
    sourcesBox.style.minHeight = '';
    outgroupsBox.style.flexShrink = '';
    outgroupsFoot.style.flexShrink = '';
  }

  if (mobile && !square && MOBILE_VIEW.outgroupsAutoFillGap) {
    outgroupsBox.style.marginTop = 'auto';
    outgroupsBox.style.marginBottom = `${mobileBottomInset}px`;
    outgroupsBox.style.flexShrink = '0';
  } else {
    outgroupsBox.style.marginTop = '';
    outgroupsBox.style.marginBottom = '';
    outgroupsBox.style.flexShrink = '';
  }

  if (square) {
    ogBox.style.display = 'none';
    if (outgroups) {
      outgroupsFoot.style.display = 'block';
      outgroupsFoot.style.position = 'static';
      outgroupsFoot.style.left = '';
      outgroupsFoot.style.right = '';
      outgroupsFoot.style.bottom = '';
      outgroupsFoot.style.marginTop = 'auto';
      outgroupsFoot.style.background = ts.headerBg;
      outgroupsFoot.style.border = `${ts.boxBorderWidth} solid ${ts.boxBorderColor}`;
      outgroupsFoot.style.borderRadius = tableRadiusFor('outgroups');
      outgroupsFoot.style.padding = `${Math.max(2, squareSpace(SQUARE_VIEW.tableCellPadYMinPx, SQUARE_VIEW.tableCellPadYMaxPx) - Math.round(4 * sqPressure))}px ${squareSpace(SQUARE_VIEW.tableCellPadXMinPx, SQUARE_VIEW.tableCellPadXMaxPx)}px`;
      outgroupsFoot.style.fontFamily = SQUARE_VIEW.outgroupsListFontFamily || TYPOGRAPHY.outgroupsCell.font;
      outgroupsFoot.style.fontWeight = SQUARE_VIEW.outgroupsListFontWeight || TYPOGRAPHY.outgroupsCell.fontWeight;
      outgroupsFoot.style.fontStyle = TYPOGRAPHY.outgroupsCell.fontStyle;
      outgroupsFoot.style.color = TYPOGRAPHY.outgroupsCell.color;
      outgroupsFoot.style.lineHeight = TYPOGRAPHY.outgroupsCell.lineHeight || '1.6';
      outgroupsFoot.style.textAlign = TYPOGRAPHY.outgroupsCell.align || 'left';
      outgroupsFoot.style.fontSize = sqPx(SQUARE_VIEW.outgroupsListFontSize, 11);
      outgroupsFoot.style.whiteSpace = 'normal';
      outgroupsFoot.style.overflow = 'visible';
      outgroupsFoot.style.textOverflow = '';
      outgroupsFoot.style.wordBreak = 'break-word';
      outgroupsFoot.style.overflowWrap = 'anywhere';
      outgroupsFoot.textContent = `RIGHT (OUTGROUPS): ${outgroups}`;
    } else {
      outgroupsFoot.style.display = 'none';
      outgroupsFoot.textContent = '';
    }
    lastRenderedMobile = mobile;
    return;
  } else {
    outgroupsFoot.style.display = 'none';
    outgroupsFoot.textContent = '';
    outgroupsFoot.style.position = '';
    outgroupsFoot.style.left = '';
    outgroupsFoot.style.right = '';
    outgroupsFoot.style.bottom = '';
    outgroupsFoot.style.marginTop = '';
    outgroupsFoot.style.background = '';
    outgroupsFoot.style.border = '';
    outgroupsFoot.style.borderRadius = '';
    outgroupsFoot.style.padding = '';
    outgroupsFoot.style.whiteSpace = '';
    outgroupsFoot.style.overflow = '';
    outgroupsFoot.style.textOverflow = '';
    outgroupsFoot.style.wordBreak = '';
    outgroupsFoot.style.overflowWrap = '';
  }

  if (outgroups) {
    ogH.textContent = ogh.text;
    applyT(ogH, ogh);
    ogH.style.textTransform = ogh.textTransform || 'uppercase';
    ogH.style.background    = ts.headerBg;
    ogH.style.borderBottom  = `${ts.headerBorderWidth} solid ${ts.headerBorderColor}`;
    ogH.style.padding       = mobile
      ? '12px 20px'
      : square
        ? `${Math.max(2, squareSpace(SQUARE_VIEW.tableHeaderPadYMinPx, SQUARE_VIEW.tableHeaderPadYMaxPx) - Math.round(3 * sqPressure))}px ${squareSpace(SQUARE_VIEW.tableCellPadXMinPx, SQUARE_VIEW.tableCellPadXMaxPx)}px`
        : '5px 10px';
    if (mobile) {
      ogH.style.fontSize      = mPx(MOBILE_VIEW.outgroupsHeaderFontSize, mob.fontScale, 11);
      ogH.style.letterSpacing = '0.1em';
    } else if (square) {
      ogH.style.fontSize      = SQUARE_VIEW.outgroupsHeaderFontSize;
    }
    applyT(ogTd, TYPOGRAPHY.outgroupsCell);
    ogTd.style.padding    = mobile
      ? `${Math.max(8, Math.round(14 * mob.rowPadScale))}px ${Math.max(12, Math.round(20 * mob.rowPadScale))}px`
      : square
        ? `${Math.max(2, squareSpace(SQUARE_VIEW.tableCellPadYMinPx, SQUARE_VIEW.tableCellPadYMaxPx) - Math.round(4 * sqPressure))}px ${squareSpace(SQUARE_VIEW.tableCellPadXMinPx, SQUARE_VIEW.tableCellPadXMaxPx)}px`
        : '5px 10px';
    ogTd.style.background = ts.cellBg;
    if (mobile) {
      ogTd.style.fontSize   = mPx(MOBILE_VIEW.outgroupsListFontSize, mob.fontScale, 12);
      ogTd.style.lineHeight = '1.8';
    } else if (square) {
      ogTd.style.fontSize = SQUARE_VIEW.outgroupsListFontSize;
    }
    ogTd.textContent    = outgroups;
    ogBox.style.display = 'block';
  } else {
    ogBox.style.display = 'none';
  }

  lastRenderedMobile = mobile;
}

function applyResponsiveHeaderStyles() {
  const mobile = isMobileLayout();
  const square = isSquareLayout();
  const tEl = document.getElementById('cardTarget');
  const slEl = document.getElementById('statLine');

  applyT(tEl, TYPOGRAPHY.target);
  if (mobile) {
    tEl.style.fontSize      = MOBILE_VIEW.targetHeadingFontSize;
    tEl.style.lineHeight    = '1.1';
    tEl.style.letterSpacing = '-0.025em';
    tEl.style.padding       = '0 4px';
  } else if (square) {
    tEl.style.fontSize      = SQUARE_VIEW.targetHeadingFontSize;
    tEl.style.lineHeight    = '1.1';
    tEl.style.letterSpacing = '-0.02em';
    tEl.style.padding       = '';
  } else {
    tEl.style.padding = '';
  }

  applyT(slEl, TYPOGRAPHY.stat);
  slEl.style.marginTop = TYPOGRAPHY.stat.marginTop || '2px';
  if (mobile) {
    slEl.style.fontSize   = MOBILE_VIEW.statFontSize;
    slEl.style.marginTop  = '8px';
    slEl.style.lineHeight = '1.4';
  } else if (square) {
    slEl.style.fontSize   = SQUARE_VIEW.statFontSize;
    slEl.style.marginTop  = `${SQUARE_VIEW.targetStatsGapPx}px`;
  }
}

function applyDonutLabelSizeForLayout() {
  if (!chartObj) return;
  const mob = getMobileAdaptiveProfile();
  const size = isMobileLayout()
    ? Math.max(9, Math.round(MOBILE_VIEW.donutPctLabelSizePx * mob.fontScale))
    : isSquareLayout()
      ? SQUARE_VIEW.donutPctLabelSizePx
      : CFG.donutPctLabelSizePx;
  chartObj.options.plugins.datalabels.font.size = size;
  chartObj.options.plugins.datalabels.font.family = numericDonutPctFontForLayout();
  const tt = getDonutTooltipFontSizesForLayout();
  chartObj.options.plugins.tooltip.bodyFont = { size: tt.body };
  chartObj.options.plugins.tooltip.titleFont = { size: tt.title };
  chartObj.update();
}

function getDonutTooltipFontSizesForLayout() {
  const mobileScale = isMobileLayout() ? Math.max(1, MOBILE_VIEW.tooltipSizeScale || 1) : 1;
  return {
    body: Math.max(10, Math.round(CFG.tooltipBodyFontSizePx * mobileScale)),
    title: Math.max(10, Math.round(CFG.tooltipTitleFontSizePx * mobileScale)),
  };
}

/* ═══════════════════════════════════════════════════════════════════════
   MAIN RENDER
═══════════════════════════════════════════════════════════════════════ */
function parseAndDraw() {
  const text   = document.getElementById('qpadmText').value.trim();
  const cardEl = document.getElementById('card');
  cardEl.style.display = 'none';
  document.getElementById('downloadBtn').style.display = 'none';
  if (!text) { setFormatBadge('', ''); return; }

  try {
    let parsed, fmtTxt, fmtCls;
    if (isRawFormat(text)) { parsed = parseRaw(text);     fmtTxt = '⚙ Raw log'; fmtCls = 'raw'; }
    else                   { parsed = parseSummary(text); fmtTxt = '✓ Summary'; fmtCls = ''; }
    setFormatBadge(fmtTxt, fmtCls);
    savePref('qpviz_theme',   currentTheme);
    savePref('qpviz_palette', document.getElementById('paletteSelect').value);

    const { target, sources, weights, sesPct, zScores, pValue, chisq, outgroups } = parsed;
    /* FIX: store target in currentParsedData so downloadImage() can use it for the filename */
    currentParsedData = { target, sources, weights, sesPct, zScores, outgroups };
    resetViewDynamicSizing();
    if (sources.length > 6) console.warn('More than 6 sources — excess rendered in grey (#888888).');

    /* Card background + ratio */
    cardEl.style.background  = CARD.bgColor;
    cardEl.style.aspectRatio = CARD.aspectRatio;
    document.getElementById('cardBg').style.background = CARD.bgColor;

    /* Stacked class */
    const prof = LAYOUT_PROFILES[activeLayout] || LAYOUT_PROFILES['landscape-wide'];
    cardEl.classList.toggle('stacked', !!prof.stacked);

    /* ─── Mobile detection (isMobileLayout now also true for portrait) ─── */
    const mobile = isMobileLayout();
    const mob = getMobileAdaptiveProfile();

    /* Header padding — tighter on mobile for more content room */
    const hp = TYPOGRAPHY.headerPadding;
    document.getElementById('cardHeader').style.padding = mobile
      ? '20px 14px 0px 14px'
      : `${hp.top} ${hp.sides} ${hp.bottom} ${hp.sides}`;

    /* Target name
       ── FIX 3: bigger heading on mobile, full-width ── */
    const tEl = document.getElementById('cardTarget');
    tEl.textContent = 'Target: ' + target;

    /* Stat line
       ── FIX 3: bigger stats text on mobile ── */
    const pd = pValue < 0.0001 ? pValue.toExponential(4) : parseFloat(pValue.toPrecision(7)).toString();
    const slEl = document.getElementById('statLine');
    let statHTML = `χ² = ${chisq.toFixed(2)}<span class="stat-sep"> / </span>p = ${pd}`;
    if (weights.some(w => w < 0))
      statHTML += ` <span style="color:#ef4444;font-size:0.7em;font-weight:700;vertical-align:middle;">⚠ neg. weight</span>`;
    slEl.innerHTML = statHTML;
    applyResponsiveHeaderStyles();

    /* Show card before measurements */
    cardEl.style.display = 'block';

    /* Verdict */
    const verdictType = resolveVerdict(weights, sesPct, zScores, pValue);
    const vb = document.getElementById('verdictBadge');
    vb.textContent     = { pass: 'PASS', weak: 'PASS*', fail: 'FAIL' }[verdictType];
    vb.dataset.verdict = verdictType;
    vb.title = {
      pass: 'Strong pass: p ≥ 0.05, all |Z| ≥ 3, low SE ratio, ≤ 4 sources',
      weak: 'Marginal pass: p ≥ 0.05 but borderline Z or SE — interpret cautiously',
      fail: 'FAIL: p < 0.05, |Z| < 2, negative weight, or large SE ratio',
    }[verdictType];
    applyVerdictPos(vb, verdictType);

    applyLayout();

    /* Table borders */
    applyTableStylesForCurrentLayout();

    /* ─── Colours ─── */
    const pidx = parseInt(document.getElementById('paletteSelect').value);
    const pal  = colorPalettes[pidx] || colorPalettes[0];

    /* originalColors: always in source order, never reversed.
       Used for swatch table and palette-switch handler. */
    originalColors  = sources.map((_, i) => i < pal.length ? pal[i] : '#888888');
    lastSourceCount = sources.length;

    /* chartColors: may be reversed for CCW direction */
    chartIsReversed = !CFG.donutClockwise;
    const chartColors  = CFG.donutClockwise ? [...originalColors] : [...originalColors].reverse();
    const chartWeights = CFG.donutClockwise ? [...weights]        : [...weights].reverse();
    const chartLabels  = CFG.donutClockwise ? [...sources]        : [...sources].reverse();
    lastColors = [...chartColors];
    const ttFonts = getDonutTooltipFontSizesForLayout();

    /* ─── Donut chart ─── */
    const ctx = document.getElementById('donutChart').getContext('2d');

    /* FIX: guard chartObj.destroy() so a failed draw phase never leaves a
       dangling destroyed instance. null it before re-assigning. */
    if (chartObj) {
      try { chartObj.destroy(); } catch(e) { /* already destroyed */ }
      chartObj = null;
    }

    chartObj = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: chartLabels,
        datasets: [{
          data:                 chartWeights,
          backgroundColor:      chartColors,
          hoverBackgroundColor: [...chartColors],
          borderColor:          CFG.donutBorderC,
          hoverBorderColor:     CFG.donutBorderC,
          borderWidth:          CFG.donutBorderW,
          hoverBorderWidth:     CFG.donutBorderW,
          hoverOffset:          CFG.donutHoverOff,
        }],
      },
      options: {
        responsive: true,
        cutout: CFG.donutCutout,
        rotation: CFG.donutStartAngle,
        /* Always +360 — direction is controlled by data order, not circumference */
        circumference: 360,
        layout: { padding: CFG.donutHoverOff },
        plugins: {
          legend: { display: false },
          tooltip: {
            titleFont: { size: ttFonts.title },
            bodyFont: { size: ttFonts.body },
            callbacks: { label: c => ` ${c.label}: ${c.parsed.toFixed(1)}%` },
          },
          datalabels: {
            display: (ctx) => showLabels && ctx.dataset.data[ctx.dataIndex] > 5,
            color:   (ctx) => labelColorFor(lastColors[ctx.dataIndex] || '#888888'),
            font: {
              family: numericDonutPctFontForLayout(),
              weight: 700,
              size: mobile
                ? Math.max(9, Math.round(MOBILE_VIEW.donutPctLabelSizePx * mob.fontScale))
                : isSquareLayout()
                  ? SQUARE_VIEW.donutPctLabelSizePx
                  : CFG.donutPctLabelSizePx,
            },
            formatter: (val) => val.toFixed(1) + '%',
            textShadowBlur:  4,
            textShadowColor: 'rgba(0,0,0,0.4)',
          },
        },
        animation: { animateRotate: true, duration: 550 },
      },
    });

    /* FIX: set aria-label on the canvas for screen-reader accessibility */
    document.getElementById('donutChart').setAttribute(
      'aria-label',
      `Admixture donut chart for ${target}: ${sources.map((s,i)=>`${s} ${weights[i].toFixed(1)}%`).join(', ')}`
    );

    /* Sources + outgroups re-render based on current view mode */
    renderInfoPanelsForCurrentLayout();

    /* Signature */
    applySignature();

    /* Second layout pass after paint */
    requestAnimationFrame(() => {
      applyLayout();
      applyVerdictPos(vb, verdictType);
      requestAnimationFrame(() => {
        applyLayout();
        applyVerdictPos(vb, verdictType);
      });
    });

    document.getElementById('downloadBtn').style.display = 'inline-block';

  } catch(e) {
    currentParsedData = null;
    lastRenderedMobile = null;
    showBadgeError(e.message);
    console.error(e);
  }
}

/* ═══════════════════════════════════════════════════════════════════════
   LIVE PALETTE SWITCH (no re-parse)
   ── FIX (palette + direction state) ──
   When palette changes, rebuild originalColors from the new palette,
   then apply reversal state for chartColors so direction is preserved.

   Note: this intentionally patches the chart in-place (no re-parse) for
   instant feedback. The dual code path (parseAndDraw vs inline patch) is
   deliberate — re-parsing on every palette click would be wasteful.
═══════════════════════════════════════════════════════════════════════ */
document.getElementById('paletteSelect').addEventListener('change', () => {
  savePref('qpviz_palette', document.getElementById('paletteSelect').value);
  if (!chartObj) return;

  const pidx = parseInt(document.getElementById('paletteSelect').value);
  const pal  = colorPalettes[pidx] || colorPalettes[0];
  const n    = lastSourceCount;

  /* Rebuild original-order colors */
  originalColors = Array.from({length: n}, (_, i) => i < pal.length ? pal[i] : '#888888');

  /* Apply reversal state to get chart-order colors */
  const chartColors = chartIsReversed ? [...originalColors].reverse() : [...originalColors];
  lastColors = chartColors;

  chartObj.data.datasets[0].backgroundColor      = [...chartColors];
  chartObj.data.datasets[0].hoverBackgroundColor = [...chartColors];

  /* Refresh datalabels color callback */
  chartObj.options.plugins.datalabels.color =
    (ctx) => labelColorFor(lastColors[ctx.dataIndex] || '#888888');

  chartObj.update();

  /* Update swatches — always original order */
  updateSourceColors(originalColors);
});

/* ═══════════════════════════════════════════════════════════════════════
   RESIZE (debounced 60 ms)
═══════════════════════════════════════════════════════════════════════ */
let _rTimer;
window.addEventListener('resize', () => {
  clearTimeout(_rTimer);
  _rTimer = setTimeout(() => {
    if (document.getElementById('card').style.display === 'none') return;
    const mobileNow = isMobileLayout();
    if (lastRenderedMobile !== null && mobileNow !== lastRenderedMobile) {
      renderInfoPanelsForCurrentLayout();
    }
    applyTableStylesForCurrentLayout();
    applyResponsiveHeaderStyles();
    applyDonutLabelSizeForLayout();
    applyLayout();
    const vb = document.getElementById('verdictBadge');
    if (vb.textContent) applyVerdictPos(vb, vb.dataset.verdict || 'fail');
  }, 60);
});

/* ═══════════════════════════════════════════════════════════════════════
   KEYBOARD SHORTCUTS
   Ctrl+Enter → Generate
   Ctrl+O     → Upload file
═══════════════════════════════════════════════════════════════════════ */
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); parseAndDraw(); }
  if ((e.ctrlKey || e.metaKey) && e.key === 'o')     { e.preventDefault(); document.getElementById('fileInput').click(); }
});

/* ═══════════════════════════════════════════════════════════════════════
   DOWNLOAD
   FIX 1: use target name in filename instead of bare timestamp.
   FIX 2: show a loading state ("Saving…") while html2canvas runs.
   FIX 3: add .catch() so card.style.overflow is always restored and
          the user gets feedback on failure instead of silent breakage.
═══════════════════════════════════════════════════════════════════════ */
function downloadImage() {
  const card = document.getElementById('card');
  const btn  = document.getElementById('downloadBtn');
  const origLabel = btn.textContent;

  /* Loading state */
  btn.textContent = 'Saving…';
  btn.disabled    = true;

  /* Safe target name for filename (strip characters invalid in filenames) */
  const targetName = (currentParsedData && currentParsedData.target)
    ? currentParsedData.target.replace(/[^a-z0-9_\-]/gi, '_').replace(/_+/g, '_').replace(/^_|_$/g, '')
    : 'export';

  card.style.overflow = 'hidden';
  html2canvas(card, { scale: 3, backgroundColor: CARD.bgColor, useCORS: true })
    .then(canvas => {
      const a = document.createElement('a');
      a.download = `qpViz_${targetName}_${Date.now()}.png`;
      a.href = canvas.toDataURL('image/png');
      a.click();
    })
    .catch(err => {
      console.error('qpViz download failed:', err);
      alert('Download failed — check the console for details. (This can happen if fonts are blocked by CORS.)');
    })
    .finally(() => {
      card.style.overflow = '';
      btn.textContent = origLabel;
      btn.disabled    = false;
    });
}

/* Init */
loadPrefs();
</script>
</body>
</html>
